import{_ as a,W as s,X as n,Y as e}from"./framework-e28ace55.js";const t={},o=e(`<h1 id="java-virtual-machine" tabindex="-1"><a class="header-anchor" href="#java-virtual-machine" aria-hidden="true">#</a> Java Virtual Machine</h1><blockquote><p>JVM stands for Java Virtual Machine. It is a software that provides a runtime environment for executing Java programs.</p><p>Java is a high-level programming language that can run on multiple platforms, such as Windows, Linux, and macOS, without needing to be recompiled for each platform. JVM is responsible for making this possible by providing an abstraction layer between the Java program and the underlying hardware and operating system.</p><p>When a Java program is compiled, it is transformed into a platform-independent bytecode format that can be executed by the JVM. The JVM then translates the bytecode into machine code that can be understood by the host operating system.</p><p>The JVM also provides a number of other features,</p><p>such as <strong>automatic memory management (garbage collection&amp;memory allocation)</strong>, <strong>dynamic class loading</strong>, and <strong>security management</strong>,</p><p>which make it easier to develop and run Java applications.</p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20230403103945508.png" alt="image-20230403103945508"></p></blockquote><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20230401002339258.png" alt="image-20230401002339258"></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20230401002814894.png" alt="image-20230401002814894"></p><h2 id="jvm-structure" tabindex="-1"><a class="header-anchor" href="#jvm-structure" aria-hidden="true">#</a> JVM Structure</h2><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220927101506965.png" alt="image-20220927101506965"></p><h3 id="jvm的架构模型-基于栈式架构" tabindex="-1"><a class="header-anchor" href="#jvm的架构模型-基于栈式架构" aria-hidden="true">#</a> <strong>JVM的架构模型 基于栈式架构</strong></h3><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220920102914097.png" alt="image-20220920102914097"></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220920102933595.png" alt="image-20220920102933595"></p><h3 id="jvm生命周期" tabindex="-1"><a class="header-anchor" href="#jvm生命周期" aria-hidden="true">#</a> JVM生命周期</h3><p><strong>启动——执行——退出</strong></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220920103222871.png" alt="image-20220920103222871"></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220920103234998.png" alt="image-20220920103234998"></p><h2 id="jvm-parameters-setting" tabindex="-1"><a class="header-anchor" href="#jvm-parameters-setting" aria-hidden="true">#</a> JVM Parameters Setting</h2><p>https://www.oracle.com/java/technologies/javase/vmoptions-jsp.html</p><blockquote><h3 id="heap-memory-management" tabindex="-1"><a class="header-anchor" href="#heap-memory-management" aria-hidden="true">#</a> <strong>heap memory management</strong></h3><table><thead><tr><th>Option and Default Value</th><th>Description</th></tr></thead><tbody><tr><td>-Xmx [Unit]</td><td>Maximum use memory size(default 1/4 system memory)</td></tr><tr><td>-Xms [Unit]</td><td>Minimum use memory size(default 1/64 system memory)</td></tr><tr><td>-XX:NewSize= [Unit]</td><td>Young generation heap size</td></tr><tr><td>-XX:MaxNewSize= [Unit]</td><td>Young generation max heap size</td></tr><tr><td>-XX:NewRatio=n</td><td>Ratio of old/new generation sizes. The default value is 2.</td></tr><tr><td>-XX:SurvivorRatio=n</td><td>Ratio of eden/survivor space size. The default value is 8.</td></tr><tr><td>-XX:MaxPermSize= [Unit]</td><td>Permanent generation max heap size</td></tr><tr><td>-XX:PermSize= [Unit]</td><td>Permanent heap size</td></tr><tr><td>-XX:MaxMetaspaceSize=metaspace size[unit]</td><td>Size is not defined. JVM automatically increases it.We can set Metaspace size</td></tr><tr><td>-XX:MaxDirectMemorySize=1g</td><td>Sets the maximum size of direct memory.</td></tr><tr><td>-XX:MaxHeapSize=1g</td><td>Sets the maximum size of heap memory.</td></tr><tr><td>-XX:MaxHeapFreeRatio=70</td><td>Maximum percentage of heap free after GC to avoid shrinking.</td></tr><tr><td>-XX:MinHeapFreeRatio=30</td><td>sets the minimum percentage of heap free after GC to avoid expansion.</td></tr><tr><td>-XX:+UseTLAB</td><td>Use thread-local allocation buffer</td></tr></tbody></table><h3 id="gc-logging" tabindex="-1"><a class="header-anchor" href="#gc-logging" aria-hidden="true">#</a> GC Logging</h3><table><thead><tr><th>Option and Default Value</th><th>Description</th></tr></thead><tbody><tr><td>-XX:+PrintGCDetails</td><td>Print GC details Messages</td></tr><tr><td>-XX:+PrintGCDateStamps</td><td>Can be used for the printing of a date stamp at every GC</td></tr><tr><td>-Xloggc:/home/DATA/filename</td><td>Log GC verbose output to specified file. The verbose output is controlled by the normal verbose GC flags.</td></tr><tr><td>-XX:+UseGCLogFileRotation</td><td>Enabled GC log rotation</td></tr><tr><td>-XX:NumberOfGClogFiles=1</td><td>Set the number of files to use when rotating logs, default value is 1 and it should be always &gt;=1</td></tr><tr><td>-XX:GCLogFileSize=8K</td><td>The size of the log file at which point the log will be rotated, must be &gt;= 8K.default will be set to 512K</td></tr></tbody></table><h3 id="class-information-tracking" tabindex="-1"><a class="header-anchor" href="#class-information-tracking" aria-hidden="true">#</a> Class information tracking</h3><table><thead><tr><th>Option and Default Value</th><th>Description</th></tr></thead><tbody><tr><td>-verbose className</td><td>Displays detailed information about the class loading, including the ClassLoader to which the class name is loaded.</td></tr><tr><td>-XX:+TraceClassLoading</td><td>Trace loading of classes.</td></tr><tr><td>-XX:+TraceClassUnloading</td><td>Trace unloading of classes.</td></tr><tr><td>-XX:+PrintClassLoaders</td><td>Displays information about all classloaders , including ClassLoader types and parent-child relationships</td></tr><tr><td>-XX:+PrintClassHistogram</td><td>Print a histogram(JVM中所有已加载类的统计信息，包括类的数量、大小等) of class instances.</td></tr><tr><td>-XX:-TraceClassResolution</td><td>Trace constant pool resolutions.</td></tr><tr><td>-XX:+PrintCompilation</td><td>打印JIT编译器编译的方法的详细信息，包括编译时间、编译级别等</td></tr><tr><td>-XX:+PrintTenuringDistribution</td><td>Print tenuring age information.</td></tr></tbody></table><h3 id="garbage-collection" tabindex="-1"><a class="header-anchor" href="#garbage-collection" aria-hidden="true">#</a> Garbage Collection</h3><table><thead><tr><th>Option and Default Value</th><th>Description</th></tr></thead><tbody><tr><td>-XX:+UseSerialGC</td><td>Use Serial Collector</td></tr><tr><td>–XX:+UseParallelGC</td><td>Use Parallel Collector</td></tr><tr><td>XX:+USeParNewGC</td><td>Use ParNew Collector</td></tr><tr><td>XX:+USeG1GC</td><td>Use G1 Collector</td></tr><tr><td>-XX:+UseAdaptiveSizePolicy</td><td>Enable an adaptive garbage collection policy</td></tr><tr><td>-XX:-DisableExplicitGC</td><td>Disable explicit GC such:System.gc()</td></tr></tbody></table><h3 id="thread-paramerters" tabindex="-1"><a class="header-anchor" href="#thread-paramerters" aria-hidden="true">#</a> Thread Paramerters</h3><table><thead><tr><th>Option and Default Value</th><th>Description</th></tr></thead><tbody><tr><td>-XX:ThreadStackSize=512</td><td>Thread Stack Size</td></tr><tr><td>-XX:ParallelGCThreads=n</td><td>Sets the number of garbage collection threads in the young and old parallel garbage collectors.</td></tr></tbody></table></blockquote><h2 id="look-up-jvm-information" tabindex="-1"><a class="header-anchor" href="#look-up-jvm-information" aria-hidden="true">#</a> Look up JVM information</h2><h3 id="cmd" tabindex="-1"><a class="header-anchor" href="#cmd" aria-hidden="true">#</a> CMD</h3><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20230608145450876.png" alt="image-20230608145450876"></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>D:<span class="token punctuation">\\</span>IDEA_2019_1_3<span class="token punctuation">\\</span>WorkSpace<span class="token punctuation">\\</span>statistics-analysis<span class="token operator">&gt;</span>jps
<span class="token number">19504</span> CepreiApplication
<span class="token number">21312</span> Launcher
<span class="token number">4432</span> Jps
<span class="token number">8740</span> KotlinCompileDaemon
<span class="token number">12088</span> RemoteMavenServer
<span class="token number">18540</span>

D:<span class="token punctuation">\\</span>IDEA_2019_1_3<span class="token punctuation">\\</span>WorkSpace<span class="token punctuation">\\</span>statistics-analysis<span class="token operator">&gt;</span>jinfo <span class="token parameter variable">-flags</span> <span class="token number">19504</span>
Attaching to process ID <span class="token number">19504</span>, please wait<span class="token punctuation">..</span>.
Debugger attached successfully.
Server compiler detected.
JVM version is <span class="token number">25.162</span>-b12
Non-default VM flags: <span class="token parameter variable">-XX:-BytecodeVerificationLocal</span> <span class="token parameter variable">-XX:-BytecodeVerificationRemote</span> <span class="token parameter variable">-XX:CICompilerCount</span><span class="token operator">=</span><span class="token number">12</span> <span class="token parameter variable">-XX:InitialHeapSize</span><span class="token operator">=</span><span class="token number">532676608</span> <span class="token parameter variable">-XX:+ManagementServer</span> <span class="token parameter variable">-XX:MaxHeapSize</span><span class="token operator">=</span><span class="token number">851443712</span>
<span class="token number">0</span> <span class="token parameter variable">-XX:MaxNewSize</span><span class="token operator">=</span><span class="token number">2837970944</span> <span class="token parameter variable">-XX:MinHeapDeltaBytes</span><span class="token operator">=</span><span class="token number">524288</span> <span class="token parameter variable">-XX:NewSize</span><span class="token operator">=</span><span class="token number">177209344</span> <span class="token parameter variable">-XX:OldSize</span><span class="token operator">=</span><span class="token number">355467264</span> <span class="token parameter variable">-XX:TieredStopAtLevel</span><span class="token operator">=</span><span class="token number">1</span> <span class="token parameter variable">-XX:+UseCompressedClassPointers</span> <span class="token parameter variable">-XX:+UseCompressedOops</span> -XX:+
UseFastUnorderedTimeStamps <span class="token parameter variable">-XX:-UseLargePagesIndividualAllocation</span> <span class="token parameter variable">-XX:+UseParallelGC</span>
Command line:  <span class="token parameter variable">-XX:TieredStopAtLevel</span><span class="token operator">=</span><span class="token number">1</span> <span class="token parameter variable">-Xverify:none</span> <span class="token parameter variable">-Dspring.output.ansi.enabled</span><span class="token operator">=</span>always <span class="token parameter variable">-Dcom.sun.management.jmxremote</span> <span class="token parameter variable">-Dspring.jmx.enabled</span><span class="token operator">=</span>true <span class="token parameter variable">-Dspring.liveBeansView.mbeanDomain</span> <span class="token parameter variable">-Dsp</span>
<span class="token assign-left variable">ring.application.admin.enabled</span><span class="token operator">=</span>true -javaagent:D:<span class="token punctuation">\\</span>IDEA_2019_1_3<span class="token punctuation">\\</span>IntelliJ IDEA <span class="token number">2019.1</span>.3<span class="token punctuation">\\</span>lib<span class="token punctuation">\\</span>idea_rt.jar<span class="token operator">=</span><span class="token number">52294</span>:D:<span class="token punctuation">\\</span>IDEA_2019_1_3<span class="token punctuation">\\</span>IntelliJ IDEA <span class="token number">2019.1</span>.3<span class="token punctuation">\\</span>bin <span class="token parameter variable">-Dfile.encoding</span><span class="token operator">=</span>UTF-8

D:<span class="token punctuation">\\</span>IDEA_2019_1_3<span class="token punctuation">\\</span>WorkSpace<span class="token punctuation">\\</span>statistics-analysis<span class="token operator">&gt;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="debug-run-configurations-idea-interface" tabindex="-1"><a class="header-anchor" href="#debug-run-configurations-idea-interface" aria-hidden="true">#</a> Debug/Run Configurations(IDEA Interface)</h3><blockquote><p>-XX:+PrintCommandLineFlags</p></blockquote><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20230608145750396.png" alt="image-20230608145750396"></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20230608145825948.png" alt="image-20230608145825948"></p><h2 id="class-loading-subsystem" tabindex="-1"><a class="header-anchor" href="#class-loading-subsystem" aria-hidden="true">#</a> Class Loading Subsystem</h2><h3 id="类加载器和类的加载过程" tabindex="-1"><a class="header-anchor" href="#类加载器和类的加载过程" aria-hidden="true">#</a> 类加载器和类的加载过程</h3><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220920104243326.png" alt="image-20220920104243326"></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220920104757585.png" alt="image-20220920104757585"></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220920104740671.png" alt="image-20220920104740671"></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220920110604499.png" alt="image-20220920110604499"></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220920110910892.png" alt="image-20220920110910892"></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220920110924167.png" alt="image-20220920110924167"></p><h3 id="类的加载过程" tabindex="-1"><a class="header-anchor" href="#类的加载过程" aria-hidden="true">#</a> 类的加载过程</h3><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220920111431881.png" alt="image-20220920111431881"></p><p>一个Java文件从编码完成到最终运行，一般会经历两个阶段：编译期、运行期。编译，即通过javac命令，将Java文件转化为二进制字节码文件，即.class文件；运行，则是将.class文件交给JVM执行。而本文所说的类加载过程就是将.class文件中类的元信息加载进内存，创建Class对象并进行解析、初始化类变量等的过程 JVM并不是一开始就会将所有的类加载到内存，而是用到某个类，才会去加载，只加载一次，后续会说到类的加载时机</p><ol start="2"><li>类加载详解 类加载分为三个部分：加载、连接、初始化</li><li><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220920112538821.png" alt="image-20220920112538821"></li></ol><h4 id="加载" tabindex="-1"><a class="header-anchor" href="#加载" aria-hidden="true">#</a> 加载</h4><p>加载 <strong>类的加载主要的职责为将.class文件的二进制字节流读入内存</strong>(JDK1.7及之前为JVM内存(方法区)，JDK1.8及之后为本地内存(元空间))，并<strong>在堆内存中为之创建Class对象</strong>，<strong>作为.class进入内存后的数据的访问入口</strong>。</p><p><strong>在这里只是读入二进制字节流，后续的验证阶段就是要拿二进制字节流来验证.class文件，验证通过，才会将.class文件转为运行时数据结构</strong></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220920160057893.png" alt="image-20220920160057893"></p><p>​ <strong>++拓展</strong>： 在<strong>JDK1.7及以前</strong>，Hot Spot JVM(普遍在用的JVM)存在一块叫做<strong>方法区</strong>的内存，也称之为<strong>永久代</strong>，这块区域用于存放类的元数据信息，包括类的字段，版本，方法等，这块区域，可以理解为.class文件进入内存后的位置。在<strong>JDK1.8</strong>，取消了方法区，取而代之的是<strong>元数据区</strong>，该元数据区并非JVM内存，而是<strong>本地内存</strong>。此外在JDK1.7时，将常量池从方法区移除，在堆内存开辟了一块空间作为常量池，有人说这是为取消方法区做的准备。更多请点我看思维导图总结 ​ <strong>++加分项： 为何取消方法区</strong>？ ​ 官方说法为：<strong>移除永久代是为融合HotSpot JVM与 JRockit VM而做出的努力</strong>，<strong>因为JRockit没有永久代</strong>，不需要配置永久代 ​ 现实使用中存在问题：方法区存储类的元数据信息，我们不清楚一个程序到底有多少类需要被加载，且方法区位于JVM内存，我们不清楚需要给方法区分配多大内存，太小容易PermGen OOM，太大，在触发Full GC时又极其影响性能，同时还存在一些内存泄露的问题</p><h4 id="链接" tabindex="-1"><a class="header-anchor" href="#链接" aria-hidden="true">#</a> 链接</h4><h5 id="验证" tabindex="-1"><a class="header-anchor" href="#验证" aria-hidden="true">#</a> 验证</h5><p>该阶段主要是为了<strong>保证加载进来的字节流符合JVM的规范</strong>，<strong>不会对JVM有安全性问题</strong>。其中有对元数据的验证，例如检查类是否继承了被final修饰的类；还有对符号引用的验证，例如校验符号引用是否可以通过全限定名找到，或者是检查符号引用的权限(private、public)是否符合语法规定等。</p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220920160256311.png" alt="image-20220920160256311"></p><p>主要包括四种验证：<strong>文件格式验证</strong> <strong>元数据验证</strong> <strong>字节码验证</strong> <strong>符号引用验证</strong></p><h5 id="准备" tabindex="-1"><a class="header-anchor" href="#准备" aria-hidden="true">#</a> 准备</h5><p>准备阶段的主要任务是<strong>为类的类变量（static）开辟空间并赋默认值</strong>。</p><p>1、静态变量是基本类型（int、long、short、char、byte、boolean、float、double）的默认值为0 2、静态变量是引用类型的，默认值为null 3、静态常量默认值为声明时设定的值</p><p><strong>例如：public static final int i = 3; 在准备阶段，i的值即为3</strong></p><p><strong>static final 在编译的时候就分配 准备阶段会显示初始化</strong></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ClassLoadingTest</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> num1 <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token comment">//prepare:num = 3;//static final在准备阶段就显示初始化</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//prepare:num = 0;initial:num = 1;准备阶段的主要任务是**为类的类变量（static）开辟空间并赋默认值**</span>
    <span class="token annotation punctuation">@Test</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>这里不会为实例变量分配初始化，</strong> <strong>类变量会分配在方法区中，而实例变量会随着对象一起分配到Java堆中</strong></p><h5 id="解析" tabindex="-1"><a class="header-anchor" href="#解析" aria-hidden="true">#</a> 解析</h5><p><strong>该阶段的主要职责为将Class在常量池中的符号引用转变为直接引用</strong>，</p><p>此处针对的是<strong>静态方法及属性和私有方法与属性</strong>，<strong>因为这类方法与私有方法不能被重写</strong>，静态属性在运行期也没有多态这一说，即<strong>在编译器可知，运行期不可变，所以适合在该阶段解析</strong>，譬如类方法main替换为直接引用，为静态连接，区别于运行时的动态连接(后续我会写关于JVM内存结构的文章，在讲解栈帧时会介绍动态链接)。 <strong>符号引用即字符串，说白了可以是一个字段名，或者一个方法名</strong>；<strong>直接引用即偏移量</strong>，<strong>说白了就是类的元信息位于内存的地址串</strong>，例如，一个类的方法为test()，则符号引用即为test，这个方法存在于内存中的地址假设为0x123456，则这个地址则为直接引用</p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220927090611262.png" alt="image-20220927090611262"></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220927090624171.png" alt="image-20220927090624171"></p><h4 id="初始化" tabindex="-1"><a class="header-anchor" href="#初始化" aria-hidden="true">#</a> 初始化</h4><p>类的<strong>初始化顺序</strong>：先执行父类静态变量赋值、父类静态初始化块，再执行子类静态属性赋值、静态初始化块</p><p><strong>执行类的构造器方法（clinit（））的过程（负责给static属性显示赋非默认值）</strong></p><p><strong>此方法不需要定义 是javac编译器自动收集类中的所有 类变量（static）的赋值动作和静态代码块中的语句合并而来</strong></p><p><strong>clinit（）构造器方法中的指令语句是按照源文件中出现的顺序</strong></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220920130631247.png" alt="image-20220920130631247"></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220920130824249.png" alt="image-20220920130824249"></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ClassLoadingTest1</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//类变量</span>
    <span class="token keyword">static</span> <span class="token punctuation">{</span><span class="token comment">//静态代码块</span>
        num <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
        number <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> number <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//2</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>number<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//10</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>clinit()方法是javac编译器自动收集类中的所有 类变量（static）的赋值动作和静态代码块中的语句合并而来</strong></p><p><strong>如果没有类变量（static）的赋值动作和静态代码块</strong> <strong>就不会有clinit()方法</strong></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220920131249704.png" alt="image-20220920131249704"></p><p><strong>任何一个类生声明后，内部至少存在一个类的构造器</strong></p><p>若该类有父类：<strong>JVM保证子类的clinit()方法执行前 父类的clinit()方法已经执行完毕</strong></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220920132635850.png" alt="image-20220920132635850"></p><div class="language-Java line-numbers-mode" data-ext="Java"><pre class="language-Java"><code>//父类先加载 其次加载子类 静态先行
public class ClassLoadingTest2 {
    static class Father{//父类先加载
        static int num = 1;
        static {
            num = 2;
        }
    }
    static class Son extends Father{//其次加载子类
        static int number = num;
    }

    public static void main(String[] args) {
        //父类先加载 其次加载子类 静态先行
        System.out.println(Son.number);//2
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>JVM必须保证一个类的clinit()方法在多线程下被同步加锁</strong></p><p><strong>保证clinit()方法只加载一次</strong></p><p><strong>clinit()方法</strong> <strong>clinit()方法是javac编译器自动收集类中的所有 类变量（static）的赋值动作和静态代码块中的语句合并而来</strong></p><p><strong>如果没有类变量（static）的赋值动作和静态代码块</strong> <strong>就不会有clinit()方法</strong></p><h3 id="类加载器" tabindex="-1"><a class="header-anchor" href="#类加载器" aria-hidden="true">#</a> 类加载器</h3><p><strong>引导类加载器（Bootstrap ClassLoader）</strong></p><p><strong>自定义类加载器（User-Defined ClassLoader）</strong></p><p><strong>所有派生于抽象类ClassLoader的类加载器划分为自定义类加载器</strong></p><p>了解自定义类加载器：</p><p>通过前面的分析可知，<strong>实现自定义类加载器需要继承ClassLoader或者URLClassLoader</strong>，<strong>继承ClassLoader则需要自己重写findClass()方法并编写加载逻辑</strong>，<strong>继承URLClassLoader则可以省去编写findClass()方法以及class文件加载转换成字节码流的代码</strong>。那么<strong>编写自定义类加载器的意义</strong>何在呢？</p><p>简单来讲:<strong>隔离加载类</strong>，<strong>修改类加载方式</strong>，<strong>扩展加载源</strong>，<strong>防止源码泄露</strong></p><p>1.当class文件不在ClassPath路径下，默认系统类加载器无法找到该class文件，在这种情况下我们需要实现一个自定义的ClassLoader来加载特定路径下的class文件生成class对象。</p><p>2.当一个class文件是通过网络传输并且可能会进行相应的加密操作时，需要先对class文件进行相应的解密后再加载到JVM内存中，这种情况下也需要编写自定义的ClassLoader并实现相应的逻辑。</p><p>3.当需要实现热部署功能时(一个class文件通过不同的类加载器产生不同class对象从而实现热部署功能)，需要实现自定义ClassLoader的逻辑。</p><h4 id="引导类加载器-bootstrap-classloader" tabindex="-1"><a class="header-anchor" href="#引导类加载器-bootstrap-classloader" aria-hidden="true">#</a> 引导类加载器（Bootstrap ClassLoader）</h4><p>启动类加载器<strong>主要加载的是JVM自身需要的类</strong>，这个类加载<strong>使用C++语言实现</strong>的，是<strong>虚拟机自身的一部分</strong>，它<strong>负责将 &lt;JAVA_HOME&gt;/lib路径下的核心类库或-Xbootclasspath参数指定的路径下的jar包加载到内存中</strong>，注意由于<strong>虚拟机是按照文件名识别加载jar包的，如rt.jar，如果文件名不被虚拟机识别，即使把jar包丢到lib目录下也是没有作用的</strong>(出于<strong>安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</strong>)。</p><h4 id="扩展类加载器-extension-classloader" tabindex="-1"><a class="header-anchor" href="#扩展类加载器-extension-classloader" aria-hidden="true">#</a> 扩展类加载器（Extension ClassLoader）</h4><p>扩展类加载器是指Sun公司(已被Oracle收购)实现的sun.misc.Launcher$ExtClassLoader类，由<strong>Java语言实现</strong>的，是<strong>Launcher的静态内部类</strong>，它<strong>负责加载&lt;JAVA_HOME&gt;/lib/ext目录下或者由系统变量-Djava.ext.dir指定位路径中的类库</strong>，开发者可以直接使用标准扩展类加载器。</p><h4 id="系统类加载器-system-classloader" tabindex="-1"><a class="header-anchor" href="#系统类加载器-system-classloader" aria-hidden="true">#</a> 系统类加载器（System ClassLoader）</h4><p>也称应用程序加载器是指 Sun公司实现的sun.misc.Launcher$AppClassLoader。它<strong>负责加载系统类路径java -classpath或-D java.class.path 指定路径下的类库</strong>，也就是我们经常用到的<strong>classpath路径</strong>，开发者可以直接使用系统类加载器，<strong>一般情况下该类加载器是程序中默认的类加载器，通过ClassLoader#getSystemClassLoader()方法可以获取到该类加载器</strong>。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ClassLoadingTest3</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//系统类加载器获取</span>
        <span class="token class-name">ClassLoader</span> systemClassLoader <span class="token operator">=</span> <span class="token class-name">ClassLoader</span><span class="token punctuation">.</span><span class="token function">getSystemClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>systemClassLoader<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//jdk.internal.loader.ClassLoaders$AppClassLoader@27c170f0</span>

        <span class="token comment">//系统类加载器获取其上层 扩展类加载器</span>
        <span class="token class-name">ClassLoader</span> systemClassLoaderParent <span class="token operator">=</span> systemClassLoader<span class="token punctuation">.</span><span class="token function">getParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>systemClassLoaderParent<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//jdk.internal.loader.ClassLoaders$PlatformClassLoader@4f3f5b24</span>

        <span class="token comment">//扩展类加载器获取其上层 引导类加载器 --获取不到</span>
        <span class="token class-name">ClassLoader</span> systemClassLoaderParentParent <span class="token operator">=</span> systemClassLoaderParent<span class="token punctuation">.</span><span class="token function">getParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>systemClassLoaderParentParent<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//null</span>

        <span class="token comment">//对于自定义类加载器 默认使用系统类加载器进行加载</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">ClassLoadingTest3</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//jdk.internal.loader.ClassLoaders$AppClassLoader@27c170f0同系统类加载器</span>

        <span class="token comment">//String类的类加载器查看 引导类加载器加载 系统的核心类库都是使用引导类加载器进行加载的</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//null</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220920134602495.png" alt="image-20220920134602495"></p><p><strong>获取ClassLoader的方式</strong></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220920144548977.png" alt="image-20220920144548977"></p><h4 id="类加载器间的关系" tabindex="-1"><a class="header-anchor" href="#类加载器间的关系" aria-hidden="true">#</a> 类加载器间的关系</h4><p>我们进一步了解类加载器间的关系(并非指继承关系)，主要可以分为以下4点</p><p><strong>启动类加载器</strong>，由C++实现，嵌套在JVM内部 加载Java核心类库 没有父类。</p><p><strong>拓展类加载器(ExtClassLoader)</strong>，派生于ClassLoader 由Java语言实现，父类加载器为启动类加载器（null 获取不到）</p><p>(Java程序默认加载器）<strong>系统类加载器(AppClassLoader)</strong>，派生于ClassLoader 由Java语言实现，父类加载器为扩展类加载器ExtClassLoader</p><p><strong>自定义类加载器</strong>，父类加载器肯定为AppClassLoader。</p><h4 id="双亲委派模式" tabindex="-1"><a class="header-anchor" href="#双亲委派模式" aria-hidden="true">#</a> 双亲委派模式</h4><p>在Java的<strong>日常应用程序开发中</strong>，<strong>类的加载几乎是由引导（Bootstrap）类加载器、扩展（Extension）类加载器、系统（System）类加载器（也称应用类加载器）3种类加载器相互配合执行的</strong>，在必要时，我们还可以自定义类加载器，需要注意的是，Java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象，而且加载某个类的class文件时，<strong>Java虚拟机采用的是双亲委派模式即把请求交由父类处理</strong>，它<strong>一种任务委派模式--双亲委派模式</strong></p><p><strong>非继承关系</strong></p><p>双亲委派模式要求<strong>除了顶层的启动类加载器外</strong>，<strong>其余的类加载器都应当有自己的父类加载器</strong>，请注意双亲委派模式中的父子关系<strong>并非通常所说的类继承关系</strong>，而是<strong>采用组合关系来复用父类加载器的相关代码</strong>，类加载器间的关系如下：</p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220920134602495.png" alt="image-20220920134602495"></p><p><strong>双亲委派模式是在Java 1.2后引入的</strong>，<strong>其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己想办法去完成.</strong></p><h5 id="双亲委派模式优势" tabindex="-1"><a class="header-anchor" href="#双亲委派模式优势" aria-hidden="true">#</a> 双亲委派模式优势</h5><h6 id="避免重复加载" tabindex="-1"><a class="header-anchor" href="#避免重复加载" aria-hidden="true">#</a> 避免重复加载</h6><p><strong>采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。</strong></p><h6 id="安全因素-沙箱安全机制" tabindex="-1"><a class="header-anchor" href="#安全因素-沙箱安全机制" aria-hidden="true">#</a> 安全因素-沙箱安全机制</h6><p><strong>防止核心API被随意篡改</strong>（对核心源码的保护）</p><p><strong>其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。</strong></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220920154750258.png" alt="image-20220920154750258"></p><p><strong>可能你会想，如果我们在classpath路径下自定义一个名为java.lang.SingleInterge类(该类是胡编的)呢？该类并不存在java.lang中，经过双亲委托模式，传递到启动类加载器中，由于父类加载器路径下并没有该类，所以不会加载，将反向委托给子类加载器加载，最终会通过系统类加载器加载该类。但是这样做是不允许，因为java.lang是核心API包，需要访问权限，强制加载将会报出如下异常</strong></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220920152230945.png" alt="image-20220920152230945"></p><p>java.lang.SecurityException: Prohibited package name: java.lang</p><p><strong>所以无论如何都无法加载成功的</strong></p><h5 id="从代码层面了解几个java中定义的类加载器及其双亲委派模式的实现" tabindex="-1"><a class="header-anchor" href="#从代码层面了解几个java中定义的类加载器及其双亲委派模式的实现" aria-hidden="true">#</a> 从代码层面了解几个Java中定义的类加载器及其双亲委派模式的实现</h5><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220920151406561.png" alt="image-20220920151406561"></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220920140502286.png" alt="image-20220920140502286"></p><p><strong>从图可以看出顶层的类加载器是ClassLoader类，它是一个抽象类，其后所有的类加载器都继承自ClassLoader（不包括启动类加载器）</strong></p><h5 id="线程上下文类加载器" tabindex="-1"><a class="header-anchor" href="#线程上下文类加载器" aria-hidden="true">#</a> 线程上下文类加载器</h5><p>在Java应用中存在着很多服务提供者接口（Service Provider Interface，SPI），这些接口允许第三方为它们提供实现，如常见的 SPI 有 JDBC、JNDI等，这些 SPI 的接口属于 Java 核心库，一般存在rt.jar包中，由Bootstrap类加载器加载，而 SPI 的第三方实现代码则是作为Java应用所依赖的 jar 包被存放在classpath路径下，由于SPI接口中的代码经常需要加载具体的第三方实现类并调用其相关方法，但SPI的核心接口类是由引导类加载器来加载的，而Bootstrap类加载器无法直接加载SPI的实现类，同时由于双亲委派模式的存在，Bootstrap类加载器也无法反向委托AppClassLoader加载器SPI的实现类。在这种情况下，我们就需要一种特殊的类加载器来加载第三方的类库，而线程上下文类加载器就是很好的选择。 线程上下文类加载器（contextClassLoader）是从 JDK 1.2 开始引入的，我们可以通过java.lang.Thread类中的getContextClassLoader()和 setContextClassLoader(ClassLoader cl)方法来获取和设置线程的上下文类加载器。如果没有手动设置上下文类加载器，线程将继承其父线程的上下文类加载器，初始线程的上下文类加载器是系统类加载器（AppClassLoader）,在线程中运行的代码可以通过此类加载器来加载类和资源，如下图所示，以jdbc.jar加载为例</p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220920152641999.png" alt="image-20220920152641999"></p><p>从图可知<strong>rt.jar核心包是有Bootstrap类加载器加载的</strong>，<strong>其内包含SPI核心接口类，由于SPI中的类经常需要调用外部实现类的方法，而jdbc.jar包含外部实现类(jdbc.jar存在于classpath路径)无法通过Bootstrap类加载器加载</strong>，因此只能<strong>委派线程上下文类加载器把jdbc.jar中的实现类加载到内存以便SPI相关类使用</strong>。显然这种线程上下文类加载器的加载方式破坏了“双亲委派模型”，<strong>它在执行过程中抛弃双亲委派加载链模式，使程序可以逆向使用类加载器，当然这也使得Java类加载器变得更加灵活</strong>。为了进一步证实这种场景，不妨看看DriverManager类的源码，DriverManager是Java核心rt.jar包中的类，该类用来管理不同数据库的实现驱动即Driver，它们都实现了Java核心包中的java.sql.Driver接口，如mysql驱动包中的com.mysql.jdbc.Driver，这里主要看看如何加载外部实现类，在DriverManager初始化时会执行如下代码</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">//DriverManager是Java核心包rt.jar的类</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DriverManager</span> <span class="token punctuation">{</span>
	<span class="token comment">//省略不必要的代码</span>
    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        <span class="token function">loadInitialDrivers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//执行该方法</span>
        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;JDBC DriverManager initialized&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token comment">//loadInitialDrivers方法</span>
 <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">loadInitialDrivers</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token class-name"><span class="token namespace">sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span></span>Providers</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
     <span class="token class-name">AccessController</span><span class="token punctuation">.</span><span class="token function">doPrivileged</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PrivilegedAction</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">public</span> <span class="token class-name">Void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
				<span class="token comment">//加载外部的Driver的实现类</span>
                <span class="token class-name">ServiceLoader</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Driver</span><span class="token punctuation">&gt;</span></span> loadedDrivers <span class="token operator">=</span> <span class="token class-name">ServiceLoader</span><span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token class-name">Driver</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
              <span class="token comment">//省略不必要的代码......</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在DriverManager类初始化时执行了loadInitialDrivers()方法,在该方法中通过ServiceLoader.load(Driver.class);去加载外部实现的驱动类，ServiceLoader类会去读取mysql的jdbc.jar下META-INF文件的内容，如下所示 <img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220920153320008.png" alt="image-20220920153320008"></p><p>很明显了确实通过线程上下文类加载器加载的，实际上<strong>核心包的SPI类对外部实现类的加载都是基于线程上下文类加载器执行的</strong>，通过这种方式实现了<strong>Java核心代码内部去调用外部实现类</strong>。我们知道<strong>线程上下文类加载器默认情况下就是AppClassLoader</strong>，</p><p>那<strong>为什么不直接通过getSystemClassLoader()获取类加载器来加载classpath路径下的类</strong>的呢？其实是可行的，但这种直接使用getSystemClassLoader()方法获取AppClassLoader加载类有一个缺点，那就是代码<strong>部署到不同服务时会出现问题</strong>，如把代码部署到Java Web应用服务或者EJB之类的服务将会出问题，因为<strong>这些服务使用的线程上下文类加载器并非AppClassLoader，而是Java Web应用服自家的类加载器，类加载器不同</strong>。，所以我们应用该少用getSystemClassLoader()。总之不同的服务使用的可能默认ClassLoader是不同的，但<strong>使用线程上下文类加载器总能获取到与当前程序执行相同的ClassLoader，从而避免不必要的问题</strong></p><h4 id="classloader卸载class" tabindex="-1"><a class="header-anchor" href="#classloader卸载class" aria-hidden="true">#</a> <strong>ClassLoader卸载Class</strong></h4><p>JVM中的Class只有满足以下三个条件，才能被GC回收，也就是该Class被卸载（unload）：</p><ul><li>该类所有的实例都已经被GC。</li><li>加载该类的ClassLoader实例已经被GC。</li><li>该类的java.lang.Class对象没有在任何地方被引用。</li></ul><p><strong>GC的时机我们是不可控的，那么同样的我们对于Class的卸载也是不可控的</strong></p><h3 id="jvm中判断class对象相同的标准" tabindex="-1"><a class="header-anchor" href="#jvm中判断class对象相同的标准" aria-hidden="true">#</a> JVM中判断class对象相同的标准</h3><p><strong>1.类的完整类名必须一致 包括包名</strong></p><p><strong>2.加载这个类的ClassLoader（指类加载器的实例对象）必须相同</strong></p><p>换言之 在JVM中 即使两个类对象（class对象）来源于同一个class文件，被同一个虚拟机所加载，但只要加载他们的ClassLoader实例对象不同，那么这两个类对象也是不同。</p><h3 id="类加载器的引用" tabindex="-1"><a class="header-anchor" href="#类加载器的引用" aria-hidden="true">#</a> 类加载器的引用</h3><p>JVM必须知道一个类的类型是由启动类加载器加载还是由用户类加载器加载。</p><p><strong>若由用户类加载器加载</strong>：<strong>JVM会将这个类加载器的一个引用作为类信息的一部分保存在方法区（jdk8元空间）中</strong>；当解析一个类型到另一个类型的引用的时候，JVM需要保证两个类型的类加载器是相同的。</p><h3 id="java程序对类的使用方式" tabindex="-1"><a class="header-anchor" href="#java程序对类的使用方式" aria-hidden="true">#</a> Java程序对类的使用方式</h3><p>会不会<strong>导致类的初始化</strong> 决定是主动使用还是被动使用</p><h4 id="主动使用" tabindex="-1"><a class="header-anchor" href="#主动使用" aria-hidden="true">#</a> 主动使用</h4><p>1.创建类的实例</p><p>2.访问某个类或接口的静态变量，或者对该静态变量赋值</p><p>3.调用类的静态方法</p><p>4.反射（Class.forName(“全类名”)）</p><p>5.初始化一个类的子类</p><p>6.Java虚拟机启动时被表明为启动类的类</p><p>7.JDK7开始提供的动态语言支持：</p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220922102407895.png" alt="image-20220922102407895"></p><h4 id="被动使用" tabindex="-1"><a class="header-anchor" href="#被动使用" aria-hidden="true">#</a> 被动使用</h4><p>除了主动使用的7种情况 其他使用Java类的方式都被看作是对类的<strong>被动使用</strong>，<strong>都不会导致类的初始化</strong>。</p><h2 id="jvm-runtime-memory-area" tabindex="-1"><a class="header-anchor" href="#jvm-runtime-memory-area" aria-hidden="true">#</a> JVM Runtime Memory Area</h2><p>https://www.digitalocean.com/community/tutorials/java-jvm-memory-model-memory-management-in-java</p><p><strong>内存</strong> 是<strong>硬盘</strong>和<strong>CPU</strong>的<strong>中间仓库及桥梁</strong> <strong>承载着操作系统和应用程序的实时运行</strong>。</p><p><strong>JVM</strong>内存布局规定了Java在运行过程中<strong>内存申请，分配，管理的策略</strong>。<strong>保证JVM的高效稳定运行</strong></p><p><strong>不同的JVM对于内存的划分方式和管理机制存在着部分差异。</strong></p><p><strong>根据《Java 虚拟机规范(Java SE 7 版)》规定</strong></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20230402223725954.png" alt="image-20230402223725954"><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220922103933396.png" alt="image-20220922103933396"><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220922104555434.png" alt="image-20220922104555434">红色的为多个线程共享，灰色的为单个线程私有的，即</p><p><strong>线程间共享：堆，对外内存。</strong></p><p><strong>每个线程：独立包括程序计数器，栈，本地方法栈</strong><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220922104700100.png" alt="image-20220922104700100"></p><h3 id="程序计数器-pc-regisster" tabindex="-1"><a class="header-anchor" href="#程序计数器-pc-regisster" aria-hidden="true">#</a> 程序计数器（PC Regisster）</h3><p><strong>Program Counter Register</strong> 程序计数寄存器</p><p><strong>作用：PC 寄存器 用来储存指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。</strong></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220922114918122.png" alt="image-20220922114918122"></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220922112757011.png" alt="image-20220922112757011"><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220922114457556.png" alt="image-20220922114457556"></p><p><strong>内存空间小，线程私有</strong>。<strong>字节码解释器工作</strong>是就是<strong>通过改变这个计数器的值来选取下一条需要执行指令的字节码指令</strong>，<strong>分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖计数器完成</strong></p><p><strong>如果线程正在执行一个 Java 方法</strong>，这个计数器记录的是<strong>正在执行的虚拟机字节码指令的地址</strong>；</p><p><strong>如果正在执行的是 Native 方法</strong>，这个计数器的值则为 <strong>(Undefined)</strong>。</p><p><strong>此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域</strong>程序计数器的特点</p><p>1.线程隔离性，每个线程工作时都有属于自己的独立计数器。 　　2.执行java方法时，程序计数器是有值的，且记录的是正在执行的字节码指令的地址（参考上一小节的描述）。 　　3.执行native本地方法时，程序计数器的值为空（Undefined）。因为native方法是java通过JNI直接调用本地C/C++库，可以近似的认为native方法相当于C/C++暴露给java的一个接口，java通过调用这个接口从而调用到C/C++方法。由于该方法是通过C/C++而不是java进行实现。那么自然无法产生相应的字节码，并且C/C++执行时的内存分配是由自己语言决定的，而不是由JVM决定的</p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220922103004735.png" alt="image-20220922103004735"></p><h4 id="程序计算器常见问题" tabindex="-1"><a class="header-anchor" href="#程序计算器常见问题" aria-hidden="true">#</a> 程序计算器常见问题</h4><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220922115103658.png" alt="image-20220922115103658"><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220922115138514.png" alt="image-20220922115138514"><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220922115320841.png" alt="image-20220922115320841"></p><h4 id="cpu时间片" tabindex="-1"><a class="header-anchor" href="#cpu时间片" aria-hidden="true">#</a> CPU时间片 <img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220922115459403.png" alt="image-20220922115459403"></h4><h4 id="cpu-并行-并发" tabindex="-1"><a class="header-anchor" href="#cpu-并行-并发" aria-hidden="true">#</a> <strong>CPU 并行 并发</strong></h4><p><strong>并发：CPU单个核心同时处理多个线程</strong>（各个线程争夺CPU时间片，在各个线程间来回高频的切换）</p><p><strong>并行：CPU多个核心处理多个线程</strong></p><h3 id="虚拟机栈-jvm-stack" tabindex="-1"><a class="header-anchor" href="#虚拟机栈-jvm-stack" aria-hidden="true">#</a> 虚拟机栈（JVM Stack）</h3><p>**线程私有，生命周期和线程一致。**描述的是 Java 方法执行的内存模型：<strong>每个方法在执行时都会床创建一个栈帧(Stack Frame)<strong>用于</strong>存储局部变量表、操作数栈、动态链接、方法出口等信息</strong>。<strong>每一个方法从调用直至执行结束，就对应着一个栈帧从虚拟机栈中入栈到出栈的过程</strong>。<strong>负责管理Java程序的运行</strong></p><p><strong>局部变量表</strong>：存放了编译期可知的各种基本类型(boolean、byte、char、short、int、float、long、double)、对象引用(reference 类型)和 returnAddress 类型(指向了一条字节码指令的地址)</p><p><strong>StackOverflowError：线程请求的栈深度大于虚拟机所允许的深度。</strong><strong>OutOfMemoryError：如果虚拟机栈可以动态扩展，而扩展时无法申请到足够的内存</strong></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220922121032602.png" alt="image-20220922121032602"></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220922121325647.png" alt="image-20220922121325647"></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220922121415970.png" alt="image-20220922121415970"></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220922120356973.png" alt="image-20220922120356973"><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220922120446022.png" alt="image-20220922120446022"><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220922120737732.png" alt="image-20220922120737732"></p><h4 id="栈可能会出现的异常" tabindex="-1"><a class="header-anchor" href="#栈可能会出现的异常" aria-hidden="true">#</a> 栈可能会出现的异常</h4><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220922121753369.png" alt="image-20220922121753369"></p><h4 id="设置栈固定的内存大小" tabindex="-1"><a class="header-anchor" href="#设置栈固定的内存大小" aria-hidden="true">#</a> 设置栈固定的内存大小</h4><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220922121856779.png" alt="image-20220922121856779"></p><h4 id="栈的储存单位-栈帧" tabindex="-1"><a class="header-anchor" href="#栈的储存单位-栈帧" aria-hidden="true">#</a> 栈的储存单位-栈帧</h4><p><strong>基本单位:栈帧</strong> <strong>线程上正在执行的每个方法对应一个栈帧</strong><strong>栈 遵循先进后出的原则 只有push压栈 pop弹出栈</strong></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220922122019231.png" alt="image-20220922122019231"></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220922122228725.png" alt="image-20220922122228725"></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220922122243126.png" alt="image-20220922122243126"></p><h4 id="栈帧的内部结构" tabindex="-1"><a class="header-anchor" href="#栈帧的内部结构" aria-hidden="true">#</a> 栈帧的内部结构</h4><p><strong>每一个栈帧</strong>都包括了<strong>局部变量表</strong>、<strong>操作数栈</strong>、动态连接、方法返回地址和一些额外的附加信息。 <strong>在编译Java程序源码的时候</strong>，<strong>栈帧中需要多大的局部变量表，需要多深的操作数栈就已经被分析计算 出来</strong>，并且<strong>写入到方法表的Code属性之中</strong>[2]。换言之，一个栈帧需要分配多少内存，并不会受到程序 运行期变量数据的影响，而仅仅取决于程序源码和具体的虚拟机实现的栈内存布局形式 <img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220922153214796.png" alt="image-20220922153214796"></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220922133628454.png" alt="image-20220922133628454"><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220922140150860.png" alt="image-20220922140150860"></p><h5 id="局部变量表" tabindex="-1"><a class="header-anchor" href="#局部变量表" aria-hidden="true">#</a> 局部变量表</h5><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220922140309136.png" alt="image-20220922140309136"><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220922144053348.png" alt="image-20220922144053348"></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220922141344440.png" alt="image-20220922141344440"></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220922141157285.png" alt="image-20220922141157285"></p><h6 id="slot槽-重复利用" tabindex="-1"><a class="header-anchor" href="#slot槽-重复利用" aria-hidden="true">#</a> slot槽 重复利用</h6><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220922144036851.png" alt="image-20220922144036851"></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220922144108124.png" alt="image-20220922144108124"></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220922144120973.png" alt="image-20220922144120973"></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220922144135710.png" alt="image-20220922144135710"></p><h6 id="静态变量和局部变量的对比" tabindex="-1"><a class="header-anchor" href="#静态变量和局部变量的对比" aria-hidden="true">#</a> 静态变量和局部变量的对比</h6><p><strong>局部变量必须显性初始化</strong></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220922144310733.png" alt="image-20220922144310733"><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220922144332069.png" alt="image-20220922144332069"></p><h6 id="静态方法-非静态方法的局部变量表" tabindex="-1"><a class="header-anchor" href="#静态方法-非静态方法的局部变量表" aria-hidden="true">#</a> 静态方法&amp;非静态方法的局部变量表</h6><p><strong>静态方法的局部变量表中无this变量 因此静态方法中无法使用this.</strong></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220922145200405.png" alt="image-20220922145200405"></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220922144804451.png" alt="image-20220922144804451"></p><p><strong>非静态方法中默认都存在this变量</strong><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220922145236412.png" alt="image-20220922145236412"></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220922144828044.png" alt="image-20220922144828044"></p><h5 id="操作数栈" tabindex="-1"><a class="header-anchor" href="#操作数栈" aria-hidden="true">#</a> 操作数栈</h5><p>操作数栈（Operand Stack）也常被称为操作栈，它是一个后入先出（Last In First Out，LIFO） 栈。同局部变量表一样，<strong>操作数栈的最大深度也在编译的时候被写入到Code属性的max_stacks数据项 之中</strong>。</p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220922153608081.png" alt="image-20220922153608081"></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220922150755930.png" alt="image-20220922150755930"></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220922150447171.png" alt="image-20220922150447171"></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220922150457435.png" alt="image-20220922150457435"><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220922150557178.png" alt="image-20220922150557178"><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220922150921447.png" alt="image-20220922150921447"></p><p><strong>代码演示</strong></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220922151651694.png" alt="image-20220922151651694"></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220922151601001.png" alt="image-20220922151601001"></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220922151610177.png" alt="image-20220922151610177"></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220922151618655.png" alt="image-20220922151618655"></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220922151630355.png" alt="image-20220922151630355"></p><h5 id="栈顶缓存技术" tabindex="-1"><a class="header-anchor" href="#栈顶缓存技术" aria-hidden="true">#</a> 栈顶缓存技术</h5><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220922152641277.png" alt="image-20220922152641277"></p><h5 id="动态链接" tabindex="-1"><a class="header-anchor" href="#动态链接" aria-hidden="true">#</a> 动态链接</h5><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220924115541013.png" alt="image-20220924115541013"></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220924115552912.png" alt="image-20220924115552912"></p><h5 id="方法的调用" tabindex="-1"><a class="header-anchor" href="#方法的调用" aria-hidden="true">#</a> 方法的调用</h5><h6 id="非虚方法" tabindex="-1"><a class="header-anchor" href="#非虚方法" aria-hidden="true">#</a> 非虚方法</h6><p><strong>早在编译期就确定了 在运行时是不可变的</strong></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220924130607798.png" alt="image-20220924130607798"></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220924130732990.png" alt="image-20220924130718490"><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220924130747487.png" alt="image-20220924130747487"></p><h6 id="虚方法" tabindex="-1"><a class="header-anchor" href="#虚方法" aria-hidden="true">#</a> 虚方法</h6><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220927090842602.png" alt="image-20220927090842602"></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220924130821628.png" alt="image-20220924130821628"></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220924130804702.png" alt="image-20220924130804702"><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220924130858208.png" alt="image-20220924130858208"></p><h6 id="普通调用指令" tabindex="-1"><a class="header-anchor" href="#普通调用指令" aria-hidden="true">#</a> 普通调用指令</h6><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220924131136904.png" alt="image-20220924131136904"></p><h6 id="动态调用指令" tabindex="-1"><a class="header-anchor" href="#动态调用指令" aria-hidden="true">#</a> 动态调用指令</h6><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220924131144565.png" alt="image-20220924131144565"><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220924131227943.png" alt="image-20220924131227943"><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220924131239943.png" alt="image-20220924131239943"></p><h5 id="方法返回地址" tabindex="-1"><a class="header-anchor" href="#方法返回地址" aria-hidden="true">#</a> 方法返回地址</h5><p><strong>方法返回</strong></p><p>当一个方法开始执行的时候，可能有<strong>正常退出</strong>和<strong>异常退出</strong>两种情况。</p><p><strong>正常退出</strong>是指方法正常完成操作并退出，没有抛出任何异常，如果当前方法正常完成，则根据当前方法返回的字节码指令进行处理。该方法返回的字节码指令中有可能存在返回值，也可能不存在返回值。</p><p><strong>异常退出</strong>是指方法执行过程中遇到异常，并且这个异常在方法体内部没有得到处理，导致方法退出。也就是说无论是Java虚拟机抛出的异常还是代码中使用throw产生的异常，只要在本方法的异常表中没有找到对应的异常处理器，就会导致方法退出。</p><p>无论方法采用何种方式退出，<strong>在方法退出后都需要返回到方法被调用的位置，程序才能继续执行</strong>，方法返回时可能需要在当前栈帧中保存一些信息，用来帮它恢复其上层方法的执行状态。<strong>方法退出过程实际上等同于把当前栈帧出栈</strong>，因此退出可以执行的操作有：<strong>恢复上层方法的局部变量表和操作数栈，如果有返回值，需要将返回值压入调用者的操作数栈中</strong>，同时<strong>调整PC计数器的值以指向方法调用指令后的下一条指令</strong>。</p><p>一般来说，<strong>方法正常退出时，调用者的PC计数器值可以作为返回地址</strong>，栈帧中可能保存此计数值，<strong>而方法异常退出时，返回地址是通过异常处理器表确定的</strong>，栈帧中一般不会保存此部分信息</p><h5 id="附加信息" tabindex="-1"><a class="header-anchor" href="#附加信息" aria-hidden="true">#</a> 附加信息</h5><h4 id="方法的结束-栈的pop" tabindex="-1"><a class="header-anchor" href="#方法的结束-栈的pop" aria-hidden="true">#</a> 方法的结束-栈的pop</h4><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token doc-comment comment">/**
 * 虚拟机栈的查看
 * 方法的结束分为两种 一种是正常的函数返回(return) 一种是抛出异常的结束 都会导致栈帧pop
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ClassLoadingTest6</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token class-name">ClassLoadingTest6</span> classLoadingTest6 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassLoadingTest6</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>classLoadingTest6<span class="token punctuation">.</span><span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Eddie&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token comment">//        System.out.println(10/0);</span>
        <span class="token keyword">return</span> <span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">method3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">method3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="虚拟机栈相关面试题" tabindex="-1"><a class="header-anchor" href="#虚拟机栈相关面试题" aria-hidden="true">#</a> 虚拟机栈相关面试题</h4><p><strong>①：举例栈溢出的情况？（溢出异常：StackOverFlowError）</strong></p><p>​ 通过-Xss设置栈的大小</p><p><strong>②：调整栈的大小，就能保证不出现栈溢出吗？</strong></p><p>​ 无法保证；比如递归调用无归情况时；</p><p><strong>③：分配的栈内存越大越好吗？</strong></p><p>​ 只是避免过早的出现溢出异常：StackOverFlowError</p><p>​ 栈内存大了 会影响线程数的数量 会挤占别的内存空间</p><p><strong>④：垃圾回收会涉及到虚拟机栈吗？</strong></p><p>​ 不会的；进栈出栈</p><p><strong>⑤：方法中定义的局部变量是否线程安全？</strong></p><p>​ 具体问题具体分析</p><p>​ 比如StringBuilder 线程不安全</p><p>​ StringBuffer线程安全</p><h3 id="本地方法栈-native-method-stack" tabindex="-1"><a class="header-anchor" href="#本地方法栈-native-method-stack" aria-hidden="true">#</a> 本地方法栈（Native Method Stack）</h3><p><strong>本地方法栈是用于管理本地方法的调用</strong></p><p><strong>当一个线程调用了一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机有同样的权限。</strong></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220924141814214.png" alt="image-20220924141814214"></p><h4 id="本地方法" tabindex="-1"><a class="header-anchor" href="#本地方法" aria-hidden="true">#</a> 本地方法</h4><p>Native标识 本地方法</p><p>一个Native Method就是一个Java调用非Java代码的接口。</p><p><strong>为了和Java环境外交互</strong></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220924141918126.png" alt="image-20220924141918126"></p><p>例如线程在调用Start（）方法来启动线程时 实际是系统调用本地方法start0（）来启动线程</p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220924142141419.png" alt="image-20220924142141419"></p><h3 id="堆-heep" tabindex="-1"><a class="header-anchor" href="#堆-heep" aria-hidden="true">#</a> 堆（heep）</h3><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20230131120051541.png" alt="image-20230131120051541"></p><h5 id="分区" tabindex="-1"><a class="header-anchor" href="#分区" aria-hidden="true">#</a> 分区</h5><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220927101930526.png" alt="image-20220927101930526"></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220927101843595.png" alt="image-20220927101843595"></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220927102014262.png" alt="image-20220927102014262"></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220927101916109.png" alt="image-20220927101916109"></p><h5 id="分区思想" tabindex="-1"><a class="header-anchor" href="#分区思想" aria-hidden="true">#</a> 分区思想</h5><p>研究表明：不同的对象 生命周期不同 百分之70-百分之90的对象都是临时对象（朝生夕死）</p><p>新生代：有Eden区和两个幸存者区Survivor0以及Survivor1（from以及to）构成；to总为空。</p><p>老年代：存放在新生代中经历多次GC（阈值默认15）仍然存活的对象</p><p><strong>分区的唯一理由就是优化GC的性能</strong></p><h5 id="新生代" tabindex="-1"><a class="header-anchor" href="#新生代" aria-hidden="true">#</a> 新生代</h5><p>新对象和没达到一定年龄的对象都在新生代</p><p>**Survivor0和Survivor1永远只有一个在被使用 两个不会同时使用 ** 即有一个幸存者空间总是空的</p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220927101941987.png" alt="image-20220927101941987"></p><h5 id="老年代" tabindex="-1"><a class="header-anchor" href="#老年代" aria-hidden="true">#</a> 老年代</h5><p>被长时间使用的对象，老年代的内存空间应该要比年轻代更大</p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220927101954168.png" alt="image-20220927101954168"></p><h5 id="元空间-非堆" tabindex="-1"><a class="header-anchor" href="#元空间-非堆" aria-hidden="true">#</a> 元空间（非堆）</h5><p>（JDK1.8 之前叫永久代）：像一些方法中的操作临时对象等，JDK1.8 之前是占用 JVM 内存，JDK1.8 之后直接使用物理内存</p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220927102003408.png" alt="image-20220927102003408"></p><h5 id="设置堆内存大小和-oom" tabindex="-1"><a class="header-anchor" href="#设置堆内存大小和-oom" aria-hidden="true">#</a> 设置堆内存大小和 OOM</h5><h5 id="手动设置" tabindex="-1"><a class="header-anchor" href="#手动设置" aria-hidden="true">#</a> 手动设置</h5><p>开发中建议将初始堆内存 和 最大堆内存设置为一样的值</p><p>-Xms6000m -Xmx6000m</p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220927103311050.png" alt="image-20220927103311050"></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220927102743735.png" alt="image-20220927102743735"></p><h5 id="默认情况" tabindex="-1"><a class="header-anchor" href="#默认情况" aria-hidden="true">#</a> 默认情况</h5><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token comment">//返回 JVM 堆大小</span>
    <span class="token keyword">long</span> initalMemory <span class="token operator">=</span> <span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">totalMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">1024</span> <span class="token operator">/</span><span class="token number">1024</span><span class="token punctuation">;</span>
    <span class="token comment">//返回 JVM 堆的最大内存</span>
    <span class="token keyword">long</span> maxMemory <span class="token operator">=</span> <span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">maxMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">1024</span> <span class="token operator">/</span><span class="token number">1024</span><span class="token punctuation">;</span>

    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;-Xms : &quot;</span><span class="token operator">+</span>initalMemory <span class="token operator">+</span> <span class="token string">&quot;M&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;-Xmx : &quot;</span><span class="token operator">+</span>maxMemory <span class="token operator">+</span> <span class="token string">&quot;M&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;系统内存大小：&quot;</span> <span class="token operator">+</span> initalMemory <span class="token operator">*</span> <span class="token number">64</span> <span class="token operator">/</span> <span class="token number">1024</span> <span class="token operator">+</span> <span class="token string">&quot;G&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;系统内存大小：&quot;</span> <span class="token operator">+</span> maxMemory <span class="token operator">*</span> <span class="token number">4</span> <span class="token operator">/</span> <span class="token number">1024</span> <span class="token operator">+</span> <span class="token string">&quot;G&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//-Xms : 254M</span>
    <span class="token comment">//-Xmx : 4064M</span>
    <span class="token comment">//系统内存大小：15G</span>
    <span class="token comment">//系统内存大小：15G</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="查看-设置的参数" tabindex="-1"><a class="header-anchor" href="#查看-设置的参数" aria-hidden="true">#</a> 查看 设置的参数</h5><p>两种方式</p><p>①:cmd--jps--jstat -gc 进程id</p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220927105415037.png" alt="image-20220927105415037"></p><p>②:-XX:+PrintGCDetails</p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220927105528630.png" alt="image-20220927105528630"></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220927105607060.png" alt="image-20220927105607060"></p><h5 id="查看-jvm-堆内存分配" tabindex="-1"><a class="header-anchor" href="#查看-jvm-堆内存分配" aria-hidden="true">#</a> 查看 JVM 堆内存分配</h5><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220927110813485.png" alt="image-20220927110813485"></p><h5 id="对象在堆中的生命周期" tabindex="-1"><a class="header-anchor" href="#对象在堆中的生命周期" aria-hidden="true">#</a> 对象在堆中的生命周期</h5><p>我们的很多对象都是朝生夕死的</p><p>一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理)</p><p>这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中</p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220927111435033.png" alt="image-20220927111435033"></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220927113802658.png" alt="image-20220927113802658"></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220927114247641.png" alt="image-20220927114247641"></p><h5 id="对象的分配过程" tabindex="-1"><a class="header-anchor" href="#对象的分配过程" aria-hidden="true">#</a> 对象的分配过程</h5><p>其中 幸存者区的from区和to区复制（复制算法）之后进行交换 谁空谁为to</p><p>一GC一交换 谁空谁是to</p><p>关于GC：频繁在新生代中收集 很少在老年代中收集，几乎不在永久代/元空间中收集</p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220927114457272.png" alt="image-20220927114457272"></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220927134856686.png" alt="image-20220927134856686"></p><h5 id="对象的分配过程的特殊情况" tabindex="-1"><a class="header-anchor" href="#对象的分配过程的特殊情况" aria-hidden="true">#</a> 对象的分配过程的特殊情况</h5><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220927121647339.png" alt="image-20220927121647339"></p><h5 id="gc-垃圾回收简介" tabindex="-1"><a class="header-anchor" href="#gc-垃圾回收简介" aria-hidden="true">#</a> GC 垃圾回收简介</h5><p><strong>我们的很多对象都是朝生夕死的</strong> <strong>因此Minor GC会频繁的触发</strong></p><p><strong>Minor GC是Eden区满时触发（Survivor区满不会触发Minor GC）</strong></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220927124003012.png" alt="image-20220927124003012"></p><p>Major GC的速度 比 Minor GC通常 要慢10倍以上 从而STW的时间更长</p><p><strong>调优时要减少Major GC的触发次数 Full GC的触发次数</strong></p><h5 id="内存分配策略-对象promotion策略" tabindex="-1"><a class="header-anchor" href="#内存分配策略-对象promotion策略" aria-hidden="true">#</a> 内存分配策略（对象Promotion策略）</h5><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220927141828861.png" alt="image-20220927141828861"></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220927141855732.png" alt="image-20220927141855732"></p><p><strong>大对象直接分配到老年代（新生代无法承载的大对象 直接分配到老年代）</strong></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220927142308928.png" alt="image-20220927142308928"></p><h5 id="堆空间的参数设置" tabindex="-1"><a class="header-anchor" href="#堆空间的参数设置" aria-hidden="true">#</a> 堆空间的参数设置</h5><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220927154321104.png" alt="image-20220927154321104"></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220927153736307.png" alt="image-20220927153736307"></p><h5 id="空间分配担保" tabindex="-1"><a class="header-anchor" href="#空间分配担保" aria-hidden="true">#</a> 空间分配担保</h5><p><strong>目前来讲jdk7以来 空间分配担保 默认为true</strong></p><p><strong>即：检测到老年代的最大可用的连续空间大于新生代所有对象的总空间（最坏情况下新生代的所有对象都存活下来要晋升到老年代）</strong></p><p>​ <strong>检测到老年代的最大可用连续空间是否大于历次晋升到老年代的对象的平均大小（按照往次的晋升统计）</strong></p><p>​ <strong>都会进行Minor GC 否则进行Full GC</strong></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220927153800393.png" alt="image-20220927153800393"></p><h5 id="tlab" tabindex="-1"><a class="header-anchor" href="#tlab" aria-hidden="true">#</a> TLAB</h5><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220927151535365.png" alt="image-20220927151535365"></p><h5 id="堆是分配对象存储的唯一选择吗" tabindex="-1"><a class="header-anchor" href="#堆是分配对象存储的唯一选择吗" aria-hidden="true">#</a> 堆是分配对象存储的唯一选择吗</h5><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220927155518020.png" alt="image-20220927155518020"></p><h5 id="逃逸分析" tabindex="-1"><a class="header-anchor" href="#逃逸分析" aria-hidden="true">#</a> 逃逸分析</h5><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220927164118327.png" alt="image-20220927164118327"></p><p>逃逸分析在JIT编译器使用</p><p>执行引擎是解释器和JIT编译器混合使用的</p><p><strong>Hotspot虚拟机没有栈上分配 因此是通过标量替换实现的；</strong> <strong>标量替换将聚合量（对象）打散成标量（基本数据类型以及对象的引用）</strong></p><p>换言之：在Hotspot虚拟机中 通过逃逸分析 发现了未发生逃逸的对象 可以进行标量替换 将其存储于栈帧中的局部变量表里。减轻堆空间的压力（GC的频率）</p><p><strong>逃逸分析(Escape Analysis)*<em>是目前 Java 虚拟机中比较前沿的优化技术*</em>。这是一种可以有效减少 Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法</strong>。通过逃逸分析，Java Hotspot 编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</p><p><strong>JDK7以来默认开启逃逸分析；</strong></p><p><strong>开发中 能使用局部变量的就尽量不在方法外定义；</strong></p><p>逃逸分析的基本行为就是分析对象动态作用域：</p><ul><li><strong>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。</strong></li><li><strong>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中，称为方法逃逸。</strong></li></ul><p>例如：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">StringBuffer</span> <span class="token function">craeteStringBuffer</span><span class="token punctuation">(</span><span class="token class-name">String</span> s1<span class="token punctuation">,</span> <span class="token class-name">String</span> s2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token class-name">StringBuffer</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>
   sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">return</span> sb<span class="token punctuation">;</span>
<span class="token punctuation">}</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>StringBuffer sb</code>是一个方法内部变量，上述代码中直接将sb返回，这样这个 StringBuffer 有可能被其他方法所改变，这样它的作用域就不只是在方法内部，虽然它是一个局部变量，但是其逃逸到了方法外部。甚至还有可能被外部线程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量，称为线程逃逸。</p><p>上述代码如果想要 <code>StringBuffer sb</code>不逃出方法，可以这样写：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">createStringBuffer</span><span class="token punctuation">(</span><span class="token class-name">String</span> s1<span class="token punctuation">,</span> <span class="token class-name">String</span> s2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token class-name">StringBuffer</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>
   sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">return</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>不直接返回 StringBuffer，那么 StringBuffer 将不会逃逸出方法。</p><p><strong>参数设置：</strong></p><ul><li>在 JDK 6u23 版本之后，HotSpot 中默认就已经开启了逃逸分析</li><li>如果使用较早版本，可以通过<code>-XX&quot;+DoEscapeAnalysis</code>显式开启</li></ul><p>开发中使用局部变量，就不要在方法外定义。</p><h5 id="使用逃逸分析-编译器可以对代码做优化" tabindex="-1"><a class="header-anchor" href="#使用逃逸分析-编译器可以对代码做优化" aria-hidden="true">#</a> <strong>使用逃逸分析，编译器可以对代码做优化：</strong></h5><p>**基于逃逸分析：**<strong>逃逸分析是以下三个操作的大前提</strong></p><p><strong>对未发生逃逸的对象：</strong></p><p><strong>栈上分配</strong> 即分配到栈帧中的局部变量表中（局部变量表中只存储基本数据类型以及对象的引用）；</p><p>因此要对未发生逃逸的对象进行<strong>标量替换</strong>将<strong>聚合量（对象）打散成标量（基本数据类型以及对象的引用）</strong></p><ul><li><strong>栈上分配</strong>：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配</li><li><strong>同步省略</strong>：如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步</li><li><strong>分离对象或标量替换</strong>：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而存储在 CPU 寄存器（Java的Hotspot中的栈）--<strong>标量替换可以视为栈上分配的一种特例</strong>；</li></ul><p>JIT 编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无需进行垃圾回收了。</p><p>常见栈上分配的场景：成员变量赋值、方法返回值、实例引用传递</p><p><strong>代码优化之同步省略（锁消除）</strong></p><ul><li>线程同步的代价是相当高的，同步的后果是降低并发性和性能</li><li>在动态编译同步块的时候，JIT 编译器可以借助逃逸分析来判断同步块所使用的锁对象是否能够被一个线程访问而没有被发布到其他线程。如果没有，那么 JIT 编译器在编译这个同步块的时候就会取消对这个代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫做<strong>同步省略，也叫锁消除</strong>。</li></ul><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">keep</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">Object</span> keeper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">synchronized</span><span class="token punctuation">(</span>keeper<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>keeper<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>    
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如上代码，代码中对 keeper 这个对象进行加锁，但是 keeper 对象的生命周期只在 <code>keep()</code>方法中，并不会被其他线程所访问到，所以在 JIT编译阶段就会被优化掉。优化成：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">keep</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">Object</span> keeper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>keeper<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>   
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>代码优化之标量替换</strong></p><p><strong>标量</strong>（Scalar）是指一个无法再分解成更小的数据的数据。Java 中的原始数据类型就是标量。</p><p>相对的，那些的还可以分解的数据叫做<strong>聚合量</strong>（Aggregate），Java 中的对象就是聚合量，因为其还可以分解成其他聚合量和标量。</p><p>在 JIT 阶段，通过逃逸分析确定该对象不会被外部访问，并且对象可以被进一步分解时，JVM 不会创建该对象，而会将该对象成员变量分解若干个被这个方法使用的成员变量所代替。这些代替的成员变量在栈帧或寄存器（Java的Hotspot中的栈）上分配空间。这个过程就是<strong>标量替换</strong>。</p><p>通过 <code>-XX:+EliminateAllocations</code> 可以开启标量替换，<code>-XX:+PrintEliminateAllocations</code> 查看标量替换情况。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token function">alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token class-name">Point</span> point <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Point</span>（<span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span>）<span class="token punctuation">;</span>
   <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;point.x=&quot;</span><span class="token operator">+</span>point<span class="token punctuation">.</span>x<span class="token operator">+</span><span class="token string">&quot;; point.y=&quot;</span><span class="token operator">+</span>point<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Point</span><span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span>     
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上代码中，point 对象并没有逃逸出 <code>alloc()</code> 方法，并且 point 对象是可以拆解成标量的。那么，JIT 就不会直接创建 Point 对象，而是直接使用两个标量 int x ，int y 来替代 Point 对象。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
   <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
   <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;point.x=&quot;</span><span class="token operator">+</span>x<span class="token operator">+</span><span class="token string">&quot;; point.y=&quot;</span><span class="token operator">+</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>      
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>代码优化之栈上分配</strong></p><p>我们通过 JVM 内存分配可以知道 JAVA 中的对象都是在堆上进行分配，当对象没有被引用的时候，需要依靠 GC 进行回收内存，如果对象数量较多的时候，会给 GC 带来较大压力，也间接影响了应用的性能。为了减少临时对象在堆内分配的数量，JVM 通过逃逸分析确定该对象不会被外部访问。那就通过标量替换将该对象分解在栈上分配内存，这样该对象所占用的内存空间就可以随栈帧出栈而销毁，就减轻了垃圾回收的压力。</p><h5 id="逃逸分析总结" tabindex="-1"><a class="header-anchor" href="#逃逸分析总结" aria-hidden="true">#</a> <strong>逃逸分析总结：</strong></h5><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220927164103083.png" alt="image-20220927164103083"></p><p>关于逃逸分析的论文在1999年就已经发表了，但直到JDK 1.6才有实现，而且这项技术到如今也并不是十分成熟的。</p><p><strong>其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。</strong></p><p>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</p><p>虽然这项技术并不十分成熟，但是他也是即时编译器优化技术中一个十分重要的手段。</p><h3 id="方法区-method-area" tabindex="-1"><a class="header-anchor" href="#方法区-method-area" aria-hidden="true">#</a> 方法区（Method Area）</h3><h4 id="方法区的理解" tabindex="-1"><a class="header-anchor" href="#方法区的理解" aria-hidden="true">#</a> 方法区的理解</h4><p><strong>方法区是一种规范</strong> 不用的JVM版本的方法区的</p><p><strong>具体实现不同</strong></p><p>比如<strong>JDK8以前的永久代</strong>以及<strong>JDK8以来的元空间</strong></p><p>虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 <strong>Non-Heap（非堆）</strong>，目的应该是与 Java 堆区分开来。所以，方法区可以看作是一块<strong>独立</strong>于 Java 堆的内存空间。</p><p>方法区与 Java 堆一样，是各个线程共享的内存区域。方法区在 JVM 启动时就会被创建，并且它的实际的物理内存空间是可以<strong>不连续</strong>的，关闭 JVM 就会释放这个区域的内存</p><p>方法区是所有线程共享的内存，在java8以前是放在JVM内存中的，由永久代实现，受JVM内存大小参数的限制，在java8中移除了永久代的内容，方法区由元空间(Meta Space)实现，并直接放到了本地内存中，不受JVM参数的限制（当然，如果物理内存被占满了，方法区也会报OOM），并且将原来放在方法区的字符串常量池和静态变量都转移到了Java堆中</p><h4 id="方法区在-jdk6、7、8中的演进细节" tabindex="-1"><a class="header-anchor" href="#方法区在-jdk6、7、8中的演进细节" aria-hidden="true">#</a> 方法区在 JDK6、7、8中的演进细节</h4><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20221024232451041.png" alt="image-20221024232451041"></p><h4 id="为什么要去永久代" tabindex="-1"><a class="header-anchor" href="#为什么要去永久代" aria-hidden="true">#</a> 为什么要去永久代</h4><p><strong>合并HotSpot和JRockit--为了兼容JRocket虚拟机（无永久代概念）</strong></p><p>JRockit从来没有所谓的永久代，也不需要开发运维人员设置永久代的大小，但是运行良好。同时也不用担心运行性能问题了,在覆盖到的测试中, 程序启动和运行速度降低不超过1%，但是这点性能损失换来了更大的安全保障</p><p><strong>为永久代设置空间大小是很难确定的。</strong></p><p>在某些场景下，如果动态加载类过多，容易产生 Perm 区的 OOM。如果某个实际 Web 工程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现 OOM。而元空间和永久代最大的区别在于，元空间不在虚拟机中，而是使用本地内存，所以默认情况下，元空间的大小仅受本地内存限制</p><p><strong>对永久代进行调优较困难</strong></p><h4 id="stringtable-为什么要调整" tabindex="-1"><a class="header-anchor" href="#stringtable-为什么要调整" aria-hidden="true">#</a> <strong>StringTable 为什么要调整</strong></h4><p>因为<strong>永久代的回收效率很低</strong>，在 <strong>full gc 的时候才会触发</strong>。而 full GC 是老年代的空间不足、永久代不足时才会触发。这就<strong>导致了<code>StringTable</code> 回收效率不高</strong>。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。<strong>放到堆里，能及时回收内存</strong></p><h4 id="方法区-method-area-的内部结构" tabindex="-1"><a class="header-anchor" href="#方法区-method-area-的内部结构" aria-hidden="true">#</a> 方法区（Method Area）的内部结构</h4><p>方法区用于存储已被虚拟机加载的<strong>类信息</strong>、<strong>常量</strong>、<strong>静态变量</strong>、<strong>即时编译器编译后的代码缓存</strong>等</p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20221024233701796.png" alt="image-20221024233701796"></p><p><strong>类型信息</strong></p><p>对每个加载的类型（ 类 class、接口 interface、枚举 enum、注解 annotation），JVM 必须在方法区中存储以下类型信息：</p><ol><li>这个类型的完整有效名称（全名=包名.类名）</li><li>这个类型直接父类的完整有效名（对于 interface 或是 java. lang.Object ，都没有父类）</li><li>这个类型的修饰符（ public ， abstract， final 的某个子集）</li><li>这个类型直接接口的一个有序列表</li></ol><p><strong>域（Field）信息</strong></p><ul><li>JVM必须在方法区中保存类型的所有域（field，也称为属性）的相关信息以及域的声明顺序；</li><li>域的相关信息包括：域名称、 域类型、域修饰符（public， private，protected， static， final， volatile， transient 的某个子集）</li></ul><p><strong>方法（Method）信息</strong></p><p>JVM 必须保存所有方法的以下信息，同域信息一样包括声明顺序：</p><ul><li>方法名称</li><li>方法的返回类型（或void）</li><li>方法参数的数量和类型（按顺序）</li><li>方法的修饰符（public， private， protected， static， final，synchronized， native ， abstract 的一个子集）</li><li>方法的字节码（bytecodes）、操作数栈、局部变量表及大小（ abstract 和 native 方法除外）</li><li>异常表（ abstract 和 native 方法除外）每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li></ul><p><strong>运行时常量池</strong></p><ul><li>在加载类和结构到虚拟机后，就会创建对应的运行时常量池</li><li>常量池表（Constant Pool Table）是 Class 文件的一部分，用于存储编译期生成的各种字面量和符号引用，<strong>这部分内容将在类加载后存放到方法区的运行时常量池中</strong></li><li>JVM 为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的</li><li>运行时常量池中包含各种不同的常量，包括编译器就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或字段引用。此时不再是常量池中的符号地址了，这里换为真实地址 <ul><li>运行时常量池，相对于 Class 文件常量池的另一个重要特征是：<strong>动态性</strong>，Java 语言并不要求常量一定只有编译期间才能产生，运行期间也可以将新的常量放入池中，String 类的 <code>intern()</code> 方法就是这样的</li></ul></li><li>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则 JVM 会抛出 OutOfMemoryError 异常。</li></ul><p>运行时常量池（Runtime Constant Pool）是方法区的一部分，理解运行时常量池的话，我们先来说说字节码文件（Class 文件）中的常量池（常量池表）</p><p><strong>常量池</strong></p><p>一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含一项信息那就是常量池表（Constant Pool Table），包含各种字面量和对类型、域和方法的符号引用。</p><p>常量池可以看作是一张表，虚拟机指令根据这张常量表找到要执行的<strong>类名</strong>、<strong>方法名</strong>、<strong>参数类型</strong>、<strong>字面量等类型</strong></p><h4 id="方法区的具体实现-具体jvm版本具体分析" tabindex="-1"><a class="header-anchor" href="#方法区的具体实现-具体jvm版本具体分析" aria-hidden="true">#</a> 方法区的具体实现（具体JVM版本具体分析）</h4><p><strong>JDK8</strong></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20221024231619374.png" alt="image-20221024231619374"></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20221025000437132.png" alt="image-20221025000437132"></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20221024235559325.png" alt="image-20221024235559325"></p><h4 id="方法区的参数设置" tabindex="-1"><a class="header-anchor" href="#方法区的参数设置" aria-hidden="true">#</a> 方法区的参数设置</h4><ul><li>永久代：OutOfMemoryError:PermGen space</li><li>元空间：OutOfMemoryError:Metaspace</li></ul><h5 id="jdk8以前" tabindex="-1"><a class="header-anchor" href="#jdk8以前" aria-hidden="true">#</a> JDK8以前</h5><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token class-name">PermSize</span><span class="token operator">=</span><span class="token class-name">N</span> <span class="token comment">//方法区 (永久代) 初始分配空间，默认值为 20.75M</span>
<span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token class-name">MaxPermSize</span><span class="token operator">=</span><span class="token class-name">N</span> <span class="token comment">//方法区 (永久代) 最大可分配空间。32位机器默认是64M，64位机器默认是82M</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="jdk8以来" tabindex="-1"><a class="header-anchor" href="#jdk8以来" aria-hidden="true">#</a> JDK8以来</h5><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token class-name">MetaspaceSize</span><span class="token operator">=</span><span class="token class-name">N</span> <span class="token comment">//方法区 (元空间) 初始分配空间，如果未指定此标志，则元空间将根据运行时的应用程序需求动态地重新调整大小。</span>
<span class="token operator">-</span><span class="token constant">XX</span><span class="token operator">:</span><span class="token class-name">MaxMetaspaceSize</span><span class="token operator">=</span><span class="token class-name">N</span> <span class="token comment">//方法区 (元空间) 最大可分配空间，默认值为 -1，即没有限制</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="方法区的垃圾回收" tabindex="-1"><a class="header-anchor" href="#方法区的垃圾回收" aria-hidden="true">#</a> 方法区的垃圾回收</h4><p>方法区的垃圾收集主要回收两部分内容：<strong>常量池中废弃的常量和不再使用的类型</strong>。</p><p>先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近 Java 语言层次的常量概念，如文本字符串、被声明为 final 的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：</p><ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul><p>HotSpot 虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收</p><p>判定一个类型是否属于“不再被使用的类”，需要同时满足三个条件：</p><ul><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类及其任何派生子类的实例</li><li>加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如 OSGi、JSP 的重加载等，否则通常很难达成</li><li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li></ul><p>Java 虚拟机被允许堆满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，不使用了就必然会回收。是否对类进行回收，HotSpot 虚拟机提供了 <code>-Xnoclassgc</code> 参数进行控制，还可以使用 <code>-verbose:class</code> 以及 <code>-XX:+TraceClassLoading</code> 、<code>-XX:+TraceClassUnLoading</code> 查看类加载和卸载信息。</p><p>在大量使用反射、动态代理、CGLib 等 ByteCode 框架、动态生成 JSP 以及 OSGi 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出</p><h2 id="java-object" tabindex="-1"><a class="header-anchor" href="#java-object" aria-hidden="true">#</a> Java Object</h2><p>==<strong>Every object has associated a monitor</strong>==</p><h3 id="创建对象的方式" tabindex="-1"><a class="header-anchor" href="#创建对象的方式" aria-hidden="true">#</a> 创建对象的方式</h3><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20221024161545402.png" alt="image-20221024161545402"></p><h3 id="创建对象的步骤" tabindex="-1"><a class="header-anchor" href="#创建对象的步骤" aria-hidden="true">#</a> 创建对象的步骤</h3><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20221024165832529.png" alt="image-20221024165832529"></p><p><strong>----加载类元信息</strong></p><p><strong>----为对象分配内存</strong></p><p><strong>----处理并发问题</strong></p><p><strong>----属性的默认初始化（零值初始化）</strong></p><p><strong>----设置对象头信息</strong></p><p><strong>----init()方法进行初始化 显示初始化 代码块中初始化 构造器初始化</strong></p><p>1.判断对象对应的类是否完成加载</p><p>虚拟机在遇到一条new指令，首先检查这个指令的参数是否能在MetaSpace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载解析初始化（即判断类元信息是否存在）。如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader+包名+类名（全类名）为key进行查找对应的.class文件。如果没有找到文件 则会抛出ClassNotFoundException异常。如果找到，则进行类加载，并在堆空间生成对应的Class对象</p><p>2.为对象分配内存</p><p>2.1内存规整--指针碰撞</p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20221024171423090.png" alt="image-20221024171423090"></p><p>2.2内存不规整</p><h3 id="内存布局" tabindex="-1"><a class="header-anchor" href="#内存布局" aria-hidden="true">#</a> 内存布局</h3><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20221024174142826.png" alt="image-20221024174142826"></p><p>例子</p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20221024174859555.png" alt="image-20221024174859555"></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20221024174521816.png" alt="image-20221024174521816"></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20221024174554702.png" alt="image-20221024174554702"></p><h3 id="访问定位" tabindex="-1"><a class="header-anchor" href="#访问定位" aria-hidden="true">#</a> 访问定位</h3><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20221120140242580.png" alt="image-20221120140242580"></p><p>两种方式</p><p><strong>直接引用（Hotspot虚拟机采用）</strong></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20221120140736479.png" alt="image-20221120140736479"></p><p>句柄访问</p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20221120140810444.png" alt="image-20221120140810444"></p><h2 id="jvm-garbage-collection" tabindex="-1"><a class="header-anchor" href="#jvm-garbage-collection" aria-hidden="true">#</a> JVM Garbage Collection</h2><blockquote><p>Java 中的垃圾回收（Garbage Collection）是自动进行的，这意味着程序员不必手动管理内存。Java 虚拟机（JVM）通过垃圾回收器（Garbage Collector）自动检测和清除无用的对象，从而释放内存空间，以便应用程序可以继续运行。</p><p>主要是在Heap Area进行</p><p>垃圾回收器是一个独立的线程，负责回收不再被引用的对象。当垃圾回收器发现一个对象没有被引用时，它会将其标记为可回收的，然后释放其占用的内存空间。</p></blockquote><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20230402225441859.png" alt="image-20230402225441859"></p><h3 id="heap-area" tabindex="-1"><a class="header-anchor" href="#heap-area" aria-hidden="true">#</a> Heap Area</h3><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20230131120051541.png" alt="image-20230131120051541"></p><h3 id="memory-allocation-strategy" tabindex="-1"><a class="header-anchor" href="#memory-allocation-strategy" aria-hidden="true">#</a> Memory allocation strategy</h3><blockquote><p>Java技术体系的自动内存管理，最根本的目标是自动化地解决两个问题：自动给对象分配内存以及自动回收分配给对象的内存。</p><ul><li><p><strong>对象优先在Eden园区进行分配</strong></p><ul><li>Eden园区有一块很小的区域TLAB：当一个线程需要创建一个对象时，JVM首先为该线程分配一个TLAB，并将该线程的TLAB指向Eden区。然后，该<strong>线程可以在自己的TLAB中分配对象，无需和其他线程竞争Eden区的空间，这样可以减少锁的争用，提高对象分配效率。</strong></li></ul></li><li><p><strong>大对象直接进入老年代</strong></p></li><li><p><strong>超过年龄阈值-XX：MaxTenuringThreshold默认15的对象将进入老年代</strong></p></li><li><p><strong>动态对象年龄判定</strong>如果在Survivor空间中相同年龄所有对象大小的总和大于 Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代</p></li><li><p><strong>空间分配担保-XX：HandlePromotionFailure</strong></p><p>检测到老年代的最大可用的连续空间大于新生代所有对象的总空间（最坏情况下新生代的所有对象都存活下来要晋升到老年代）</p><p>检测到老年代的最大可用连续空间是否大于历次晋升到老年代的对象的平均大小（按照往次的晋升统计）都会进行Minor GC 否则进行Full GC</p></li></ul><p><strong>对象的分配过程：</strong></p><ol><li>首先，当程序需要创建一个对象时，JVM会在堆区中查找是否有足够的内存空间来存储该对象。如果有足够的内存空间，则进行下一步；否则，会触发垃圾收集器来回收一些不再使用的对象，以腾出足够的内存空间。</li><li>接下来，JVM会将该对象所需的内存分配给它，此时还未初始化该对象的成员变量。</li><li>然后，JVM会调用该对象的构造方法，初始化其成员变量。</li><li>最后，JVM返回该对象的引用，使程序可以通过该引用来操作该对象。</li></ol><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220927114457272.png" alt="image-20220927114457272"></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220927114247641.png" alt="image-20220927114247641"></p></blockquote><h3 id="minor-gc-major-gc-full-gc" tabindex="-1"><a class="header-anchor" href="#minor-gc-major-gc-full-gc" aria-hidden="true">#</a> Minor GC，Major GC，Full GC</h3><blockquote><p>在 Java 中，Partial GC 和 Full GC 是两种不同的垃圾回收方式。</p><p>Partial GC</p><p>是指只对 Java 堆内存的部分区域进行垃圾回收，比如只对新生代或老年代进行回收。Partial GC 通常可以分为两种类型：Young GC 和 Old GC。Young GC（或称为 Minor GC）是针对新生代内存区域的垃圾回收，而 Old GC（或称为 Major GC）是针对老年代内存区域的垃圾回收。在执行 Partial GC 时，只有相应的内存区域会被回收，而其他内存区域则不会受到影响。因此，Partial GC 的执行时间通常比 Full GC 更短，并且不会导致应用程序的暂停。</p><ul><li>Minor GC</li><li>Major GC</li><li>Mixed GC（Only G1）</li></ul><p>Full GC</p><p>是指对整个 Java 堆内存进行垃圾回收，包括新生代和老年代。Full GC 的执行时间通常比 Partial GC 更长，并且需要暂停应用程序。在 Full GC 执行期间，所有应用程序线程都会被阻塞。由于 Full GC 需要扫描整个 Java 堆内存，因此其执行时间和频率都应该尽量降低，以保证应用程序的性能和稳定性。</p></blockquote><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20220927124003012.png" alt="image-20220927124003012"></p><h3 id="trigger-conditions-for-gc" tabindex="-1"><a class="header-anchor" href="#trigger-conditions-for-gc" aria-hidden="true">#</a> Trigger conditions for GC</h3><blockquote><p>在 Java 中，垃圾回收器会根据一定的策略和条件来触发垃圾回收。下面列举了一些触发 GC 的情况：</p><ol><li>系统空闲时：当系统空闲时，垃圾回收器可能会被触发以回收无用的对象，以便释放内存供系统使用。</li><li>内存不足时：当 JVM 发现当前的内存不足以支持程序运行时，垃圾回收器可能会被触发以回收无用的对象，以腾出更多的空间。</li><li>程序调用 System.gc() 方法：程序可以调用 System 类的静态方法 gc() 来请求垃圾回收器立即运行。但是，实际上该方法只是向垃圾回收器发送了一个请求，垃圾回收器是否会立即回收对象，仍然由垃圾回收器自行决定。</li><li>程序调用 Runtime.getRuntime().gc() 方法：与 System.gc() 方法类似，程序也可以调用 Runtime 类的 gc() 方法来请求垃圾回收器立即运行。</li><li>对象创建时：Allocation Failure,垃圾回收器可能会被触发以回收无用的对象。（对象最初先分配到Eden区 若分配时Eden园区满了就触发MinorGC）</li><li>对象存活时间：当程序中的对象已经存在一定时间，或者对象达到了一定的年龄（阈值），垃圾回收器可能会被触发以回收无用的对象。Survivor==&gt;OG</li></ol><p>需要注意的是，虽然程序可以通过调用 System.gc() 或者 Runtime.getRuntime().gc() 方法来请求垃圾回收器立即运行，但是实际上垃圾回收器是否会立即回收对象，还是由垃圾回收器自行决定。因此，在开发中，应该避免过多地依赖垃圾回收器的运行来释放资源，而是要合理地使用内存，及时释放不再需要的对象，以保证程序的性能和稳定性。</p></blockquote><h3 id="garbage-collection-algorithm" tabindex="-1"><a class="header-anchor" href="#garbage-collection-algorithm" aria-hidden="true">#</a> Garbage collection algorithm</h3><blockquote><p>Java 中的垃圾收集算法主要有以下几种：</p><ul><li><em><strong>标记-清除算法（Mark-Sweep Algorithm）</strong></em></li></ul><p>标记-清除算法是最简单、最基础的垃圾收集算法。</p><p>它<strong>分为标记和清除两个阶段：</strong></p><p>标记阶段从根节点开始，遍历所有可达对象并打上标记；</p><p>清除阶段则从头到尾遍历整个堆空间，清除所有没有标记的对象。</p><p>这个算法的<strong>缺点是会产生大量的内存碎片，从而降低内存利用率</strong>。</p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20230403001405673.png" alt="image-20230403001405673"></p><ul><li><em><strong>复制算法（Copying Algorithm）</strong></em></li></ul><p>复制算法将堆空间<strong>划分为两个区域，每次只使用其中一个区域</strong>。当该区域的内存用尽时，将其中存活的对象复制到另外一个区域中，然后清空原来的区域。</p><p>这种算法实现简单，不会产生内存碎片，</p><p>但是<strong>会浪费一半的内存空间</strong>。</p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20230403001436434.png" alt="image-20230403001436434"></p><ul><li><em><strong>标记-整理算法（Mark-Compact Algorithm）</strong></em></li></ul><p>标记-整理算法是在标记-清除算法的基础上做了一些优化。</p><p>它<strong>同样分为标记和清除两个阶段</strong>：</p><p>标记阶段遍历所有可达对象并打上标记；</p><p>清除阶段将所有存活的对象移动到堆的一端，然后清理掉堆空间的另一端。</p><p>这种算法可以避免内存碎片的产生，</p><p>但是<strong>移动存活的对象需要耗费额外的时间和空间</strong>。</p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20230403001416453.png" alt="image-20230403001416453"></p><ul><li><em><strong>分代收集算法（Generational Collection Algorithm）</strong></em></li></ul><p>分代收集算法是当前 Java 垃圾回收器中<strong>最常用的算法之一</strong>。</p><p>它将堆空间分为新生代和老年代两个区域，</p><p>新生代中大多数对象是短暂的，因此可以使用复制算法来进行垃圾回收；</p><p>老年代中的对象则更加稳定，因此可以使用标记-整理算法来进行垃圾回收。</p><p>分代收集算法利用不同年龄段对象的生命周期的不同，提高垃圾回收的效率。</p><ul><li><em><strong>增量式收集算法（Incremental Collection Algorithm）</strong></em></li></ul><p>增量式收集算法将垃圾回收过程分为多个小阶段，在每个小阶段之间允许程序执行一段时间。这种算法可以让垃圾回收的过程逐渐进行，不会造成长时间的停顿。但是这种算法需要对程序运行的状态做出一些假设，如果这些假设出现错误，可能会导致垃圾回收的不完整。因此，增量式收集算法并不是所有场景都适用。</p></blockquote><h3 id="garbage-collector" tabindex="-1"><a class="header-anchor" href="#garbage-collector" aria-hidden="true">#</a> Garbage Collector</h3><blockquote><p>HotSpot has four garbage collectors:</p><ul><li><strong>Serial:</strong> All garbage collection events are conducted serially in one thread. JVM executes the compaction after each garbage collection.</li><li><strong>Parallel:</strong> JVM uses multiple threads for minor garbage collection. It uses a single thread for major garbage collection and Old Generation compaction. Alternatively, the Parallel Old variant uses multiple threads for major garbage collection and Old Generation compaction.</li><li><strong>CMS (Concurrent Mark Sweep):</strong> Multiple threads are used for minor garbage collection using the same algorithm as Parallel. Major garbage collection is multi-threaded, like Parallel Old. Still CMS runs concurrently alongside application processes to minimize “stop the world” events (i.e., when the garbage collector running stops the application). Here, the JVM does not perform compaction of memory.</li><li><strong>G1 (Garbage First):</strong> The newest garbage collector is intended as a replacement for CMS. It is parallel and concurrent, like CMS. However, it works quite differently under the hood than older garbage collectors.</li></ul><p><strong>Till java 8, <code>parallel</code> GC was default algorithm.===&gt;Since java 9, <code>G1</code> has been set as default GC algorithm.</strong></p></blockquote><blockquote><p><strong>Serial</strong>:</p><p>Serial（串行）收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 <strong>“单线程”</strong> 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在<strong>进行垃圾收集工作的时候必须暂停其他所有的工作线程</strong>（ <strong>&quot;Stop The World&quot;</strong> ），<strong>直到它收集结束</strong>。</p><p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p><p>它<strong>简单而高效（与其他收集器的单线程相比）</strong>。Serial 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial 收集器对于运行在 Client 模式下的虚拟机来说是个不错的选择。</p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20230403003634648.png" alt="image-20230403003634648"></p></blockquote><blockquote><p><strong>Parallel Scavenge</strong>:</p><p><strong>JDK1.8 默认收集器</strong></p><p><strong>Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。</strong> Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解，手工优化存在困难的时候，使用 Parallel Scavenge 收集器配合自适应调节策略，把内存管理优化交给虚拟机去完成也是一个不错的选择。</p><p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20230403003100936.png" alt="image-20230403003100936"></p></blockquote><blockquote><p><strong>CMS（Concurrent Mark Sweep）</strong>:</p><p><strong>以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。</strong></p><p><strong>CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</strong></p><p>主要优点：<strong>并发收集、低停顿</strong>。</p><p>明显的缺点：</p><ul><li><strong>对 CPU 资源敏感；</strong></li><li><strong>无法处理浮动垃圾；</strong></li><li><strong>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</strong></li></ul><p><strong>Mark Sweep</strong>这两个词可以看出，CMS 收集器是一种 <strong>“标记-清除”算法</strong>实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：</p><ul><li><strong>初始标记：</strong> 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；</li><li><strong>并发标记：</strong> 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li><li><strong>重新标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li><li><strong>并发清除：</strong> 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。</li></ul><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20230403003741563.png" alt="image-20230403003741563"></p></blockquote><blockquote><p><strong>G1 (Garbage-First)</strong> :</p><p><strong>一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.</strong></p><p>具备以下特点：</p><ul><li><strong>并行与并发</strong>：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。</li><li><strong>分代收集</strong>：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。</li><li><strong>空间整合</strong>：与 CMS 的“标记-清除”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。</li><li><strong>可预测的停顿</strong>：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。</li></ul><p>G1 收集器的运作大致分为以下几个步骤：</p><ul><li><strong>初始标记</strong></li><li><strong>并发标记</strong></li><li><strong>最终标记</strong></li><li><strong>筛选回收</strong></li></ul><p><strong>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)</strong> 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20230403003811253.png" alt="image-20230403003811253"></p></blockquote><h3 id="judgment-of-the-object-of-death" tabindex="-1"><a class="header-anchor" href="#judgment-of-the-object-of-death" aria-hidden="true">#</a> Judgment of the object of death</h3><blockquote><p>在 Java 中，死亡对象是指无法再被应用程序访问到的对象。Java 垃圾回收器会定期扫描内存，找到这些死亡对象，并将其回收释放内存空间。Java 中判断一个对象是否为死亡对象的方法有以下两种：</p><ol><li><p><strong>引用计数法</strong>：每个对象都有一个引用计数器，当有引用指向该对象时，计数器加 1，当引用被销毁时，计数器减 1。当计数器的值为 0 时，该对象被判定为死亡对象。但是，引用计数法无法解决循环引用的问题(<strong>垃圾相互引用问题</strong>)，即两个或多个对象之间互相引用，导致它们的引用计数器的值永远不为 0，这样这些对象就会一直存在于内存中而无法被回收。</p></li><li><p><strong>可达性分析算法</strong>：<strong>可达性分析算法是一种常用的垃圾回收算法</strong>，其基本思想是通过一系列的“GC Roots”对象作为起点，从这些根对象开始遍历整个对象图，找到所有可达的对象，未被遍历到的对象即为死亡对象。Java 中的 <strong>GC Roots</strong> 对象包括：</p><ul><li>虚拟机栈中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中 JNI（Java Native Interface）引用的对象</li></ul><p><img src="https://eddie-typora-image.oss-cn-shenzhen.aliyuncs.com/typora-user-images/image-20230402234130605.png" alt="image-20230402234130605"></p></li></ol><p>可达性分析算法可以处理循环引用的问题，因为它能够识别出不再与 GC Roots 对象相连的一组对象，即为不可达对象，这些对象会被判定为死亡对象并进行回收。</p></blockquote><h3 id="the-reference-type-of-the-object" tabindex="-1"><a class="header-anchor" href="#the-reference-type-of-the-object" aria-hidden="true">#</a> The reference type of the object</h3><blockquote><p>在 Java 中，引用类型用于描述一个对象在内存中的使用情况和引用方式，Java 中共有四种引用类型，分别是：</p><ol><li><strong>强引用（Strong Reference）</strong>：最常见的引用类型，也是默认的引用类型。<strong>如果一个对象具有强引用</strong>，<strong>垃圾回收器就不会回收</strong>它，即使该对象已经没有被任何变量所引用。当程序中的某个对象拥有强引用时，该对象就一直存在于内存中，直到该引用被显式地设置为 null 或者被赋值为其他对象。</li><li><strong>软引用（Soft Reference）：<strong>用于描述一些有用但非必须的对象。如果一个对象只有软引用，那么在</strong>内存不足时，垃圾回收器可能会回收它</strong>，释放内存空间。当程序需要该对象时，可以通过软引用重新获取它。在 Java 中，软引用通常用于缓存。</li><li>**弱引用（Weak Reference）：**用于描述一些非必须的对象，比软引用更加弱化。如果一个对象只有弱引用，那么在垃圾回收时，<strong>无论内存是否充足，都会被回收</strong>，释放内存空间。弱引用通常用于解决内存泄漏问题，比如在对象与其它对象之间存在循环引用的情况下，使用弱引用可以解除这种循环引用。</li><li><strong>虚引用（Phantom Reference）：<strong>用于</strong>描述那些已经被回收的对象</strong>。虚引用无法通过它直接访问到对象的实例，也无法通过它获取对象的状态或者执行任何操作。<strong>虚引用主要用于跟踪对象被垃圾回收的状态</strong>，提供一种在对象被回收时收到系统通知的机制，可以用来进行资源清理或者其他清理操作。</li></ol></blockquote><h3 id="a-class-that-is-judged-to-be-useless" tabindex="-1"><a class="header-anchor" href="#a-class-that-is-judged-to-be-useless" aria-hidden="true">#</a> A class that is judged to be useless</h3><blockquote><p>在 Java 中，类对象通常会被加载器持有，因此判断一个类是否是无用的类需要从类加载器入手。JVM 中每个类加载器都维护了一个加载的类的列表，如果一个类不再被引用，那么该类就可以被卸载。</p><p>在垃圾回收器扫描内存时，它会从根集开始，遍历所有可达的对象，将不可达的对象标记为垃圾，然后进行回收。类加载器也是从根集开始遍历，判断是否有引用指向该类，如果没有则认为该类可以被卸载。</p><p>具体来说，JVM 中对于一个类的卸载，需要满足以下三个条件：</p><ol><li>该类的<strong>所有实例都已经被 GC 回收</strong>，即<strong>没有任何实例引用了该类</strong>。</li><li>该类的 <strong>Class 对象已经被 GC 回收</strong>。</li><li>该类的 <strong>ClassLoader 已经被 GC 回收</strong>。</li></ol><p>只有当以上三个条件都满足时，该类才可以被卸载。</p></blockquote><blockquote><p><strong>判断一个常量是废弃常量</strong></p><p>在 Java 中，常量池是 JVM 用于存储常量的区域，包括编译器生成的常量和手动添加的常量。在判断一个常量是否是废弃常量时，需要从常量池入手。</p><p>常量池中的常量分为两种类型：字面量和符号引用。字面量包括字符串、数字等常量，而符号引用包括类和方法的引用。对于一个废弃的常量，可以理解为其对应的字面量或符号引用没有被使用。</p><p>在垃圾回收器扫描内存时，会从根集开始，遍历所有可达的对象，将不可达的对象标记为垃圾，然后进行回收。常量池中的常量也是从根集开始遍历，判断是否有引用指向该常量，如果没有则认为该常量可以被回收。</p><p>具体来说，JVM 中对于一个常量的回收，需要满足以下条件：</p><ol><li>该<strong>常量所在的类没有被加载，或者该常量所在的类已经被卸载</strong>。</li><li>该<strong>常量没有被任何对象引用</strong>。</li></ol><p>只有当以上两个条件都满足时，该常量才可以被回收。</p></blockquote><h2 id="jvm-out-of-memory" tabindex="-1"><a class="header-anchor" href="#jvm-out-of-memory" aria-hidden="true">#</a> JVM Out Of Memory</h2><h2 id="jvm-performance-optimization" tabindex="-1"><a class="header-anchor" href="#jvm-performance-optimization" aria-hidden="true">#</a> JVM Performance Optimization</h2>`,527),p=[o];function i(r,c){return s(),n("div",null,p)}const d=a(t,[["render",i],["__file","jvm.html.vue"]]);export{d as default};
