const e=JSON.parse('{"key":"v-031a2230","path":"/backend/java/java_concurrency_programming.html","title":"Java Concurrency Programming","lang":"en-US","frontmatter":{"description":"理论基础 CPU 缓存模型\\r CPU Cache 缓存的是内存数据用于解决 CPU 处理速度和内存不匹配的问题(CPU 处理速度和内存处理速度不对等)，\\r 内存缓存的是硬盘数据用于解决硬盘访问速度过慢的问题\\r !image-20230412004416756 (https://eddie-typora-image.oss-cn-shenzhen.ali...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/backend/java/java_concurrency_programming.html"}],["meta",{"property":"og:site_name","content":"Eddie-Tech-Blog"}],["meta",{"property":"og:title","content":"Java Concurrency Programming"}],["meta",{"property":"og:description","content":"理论基础 CPU 缓存模型\\r CPU Cache 缓存的是内存数据用于解决 CPU 处理速度和内存不匹配的问题(CPU 处理速度和内存处理速度不对等)，\\r 内存缓存的是硬盘数据用于解决硬盘访问速度过慢的问题\\r !image-20230412004416756 (https://eddie-typora-image.oss-cn-shenzhen.ali..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java Concurrency Programming\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[]}"]]},"headers":[{"level":2,"title":"理论基础","slug":"理论基础","link":"#理论基础","children":[{"level":3,"title":"CPU 缓存模型","slug":"cpu-缓存模型","link":"#cpu-缓存模型","children":[]},{"level":3,"title":"指令重排序","slug":"指令重排序","link":"#指令重排序","children":[]},{"level":3,"title":"上下文切换","slug":"上下文切换","link":"#上下文切换","children":[]},{"level":3,"title":"并发三要素","slug":"并发三要素","link":"#并发三要素","children":[]},{"level":3,"title":"线程安全的实现方法","slug":"线程安全的实现方法","link":"#线程安全的实现方法","children":[]}]},{"level":2,"title":"线程基础","slug":"线程基础","link":"#线程基础","children":[]},{"level":2,"title":"Java并发机制的底层实现原理","slug":"java并发机制的底层实现原理","link":"#java并发机制的底层实现原理","children":[{"level":3,"title":"Java Object Memory Layout","slug":"java-object-memory-layout","link":"#java-object-memory-layout","children":[]},{"level":3,"title":"JMM(Java 内存模型)","slug":"jmm-java-内存模型","link":"#jmm-java-内存模型","children":[]},{"level":3,"title":"Memory Barrier","slug":"memory-barrier","link":"#memory-barrier","children":[]},{"level":3,"title":"Monitor","slug":"monitor","link":"#monitor","children":[]},{"level":3,"title":"synchronized","slug":"synchronized","link":"#synchronized","children":[]},{"level":3,"title":"volatile","slug":"volatile","link":"#volatile","children":[]},{"level":3,"title":"ThreadLocal","slug":"threadlocal","link":"#threadlocal","children":[]}]},{"level":2,"title":"JUC(Java Util Concurrency)","slug":"juc-java-util-concurrency","link":"#juc-java-util-concurrency","children":[{"level":3,"title":"AbstractQueuedSynchronizer","slug":"abstractqueuedsynchronizer","link":"#abstractqueuedsynchronizer","children":[]},{"level":3,"title":"Java 线程池","slug":"java-线程池","link":"#java-线程池","children":[]},{"level":3,"title":"线程池原理分析","slug":"线程池原理分析","link":"#线程池原理分析","children":[]},{"level":3,"title":"Executor 框架","slug":"executor-框架","link":"#executor-框架","children":[]},{"level":3,"title":"ThreadPoolExecutor★","slug":"threadpoolexecutor★","link":"#threadpoolexecutor★","children":[]},{"level":3,"title":"CompletableFuture异步编程","slug":"completablefuture异步编程","link":"#completablefuture异步编程","children":[]}]}],"git":{},"readingTime":{"minutes":56.38,"words":16913},"filePathRelative":"backend/java/java_concurrency_programming.md","autoDesc":true}');export{e as data};
